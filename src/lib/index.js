import './tbase'
import $ from 'jquery';
export default  function (svgPath) {
	"use strict";
	//- 
	var _SVGData = {
		_width: 1230.31396484375,
		_height: 1019.344970703125,
		series: []
	};


	_SVGData.series = [];
	for (var i in svgPath) {
		_SVGData.series.push({
			_id: "_path_" + i,
			path: svgPath[i]
		});
	}

	window.thm = this;
	this.scene;
	this.camera;
	this.renderer;
	this.controls;

	this.GId = '';
	this.container;
	this.parentCont;
	this.Tweens = [];
	this.tagConts = {};
	this.Result = false;
	//-
	this.WHRatio;
	this.svgOffset;

	this.mapObject;
	this.shapesArr = [];
	this.mEventArr = [];
	this.shapesArrLen = 0;
	//-
	this.SVGMapData;
	this.SVGMapObj = {};

	//-init
	this.init = function (cts, config, df_SVGData) {
		var conts = parseCts(cts);
		 _SVGData._width=conts.clientWidth;
		 _SVGData._height=conts.clientHeight;
		 
		if (detector() && conts != null) {
			try {
				config = config || {};
				df_Config = $.extend(true, {}, default_Config, config);

				df_SVGData = df_SVGData || _SVGData;
				thm.SVGMapData = $.extend(true, {}, df_SVGData);

				thm.parentCont = conts;
				thm.GId += THREE.Math.generateUUID();
				var TId = conts.attr('id') + '_' + thm.GId;
				thm.container = creatContainer(TId);
				thm.parentCont.html(thm.container);
				_Collects.loadTexture();
				__setControls();

				initiate();
				is_Init = true;
			} catch (e) {
				thm.Result = 'error! Initialization Error!';
				creatError(conts);
				return;
			}
		} else thm.Result = 'error! Not Support WebGL!';
	};

	this.render = function (func) {
		if (is_Init) {
			renderers(func);
		}
	};

	this.disposeRender = function () {
		if (is_Init && testing()) {
			removeEvent();
			thm.controls.dispose();
			thm.container.remove();
			thm.renderer.forceContextLoss();
			thm.renderer.domElement = null;
			thm.renderer.context = null;
			thm.renderer = null;
			is_Init = false;
		}
	};

	//-
	this.setSVGMap = function (data, opt) {
		if (is_Init) {
			init3DMesh(data);
			opt && thm._setAdmissionDynamic(opt);
		}
	};

	//-
	this.onMouseDownEvent = function (func) {
		df_MouseDownCallback = toFunction(func);
	};

	//-
	this.setBlockHeight = function (param) {
		if (is_Init) {
			//_Collects.handleBlockHeight( param );
		}
	};

	//-
	this.setTypeVisible = function (type, name) {
		if (is_Init) {
			//thm._setAdmissionDynamic( { type: 1 } );
			//_Collects.handleTypeVisible( type, name );
		}
	};

	//-
	this._setAdmissionDynamic = function (opt) {
		if (is_Init) {
			opt = opt || {};
			df_AdmisDic = $.extend(true, {}, default_AdmissionDynamic, opt);
			df_AdmisDic.type = _Collects.limit(df_AdmisDic.type * 1, [0, 1, 2]);
			df_AdmisDic.perTime = _Collects.clamp(df_AdmisDic.perTime * 1, 0.1, 5, 2);
			df_AdmisDic._transTimes = (df_AdmisDic.type && -1) || (!df_AdmisDic.type && 0);
		}
	};

	//-
	var thm = this;
	var df_Raycaster, df_Mouse, df_MouseEvent = false,
		df_Intersects, df_ItdMesh, df_ItdMesh2; //tips & event
	var df_Clock, df_Width = 0,
		df_Height = 0,
		is_Init = false,
		_MDown = 0,
		_vecStart,
		df_LableMtl, df_pointMtl, df_pointMtl2; //essential

	//- callback
	var df_MouseDownCallback = toFunction();

	//- AdmissionDynamic
	var df_AdmisDic = {};
	var default_AdmissionDynamic = {
		type: 0,
		perTime: 1.8,
		_transTimes: -1,
	};

	//- default setting
	var df_Config = {};
	var default_Config = {
		tags: {
			fontColor: "RGBA(212,214,226,.9)",
			fontHover: "RGBA(255,0,0,.9)",
			fontSize: 1.4,
		},
		sceneStyle: {
			blockColor: "RGBA(27,48,94,.96)",

			blockHeight: 2,

			borderColor: "RGBA(31,130,161,1)",
			borderWidth: 1.6,
		},
		texture: {
			df_p1: 'data:image/png;base64,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',
			df_p2: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAABaVSURBVHja7J1bbyTJcYUjq5ukZrWSVzZswRZgwD9A//+PGPCjHmxYD/ZqtdrL7LC7K/0wWWYwJ291r6z8DkCQ7O6qrkueEyciL2WstQIAaBMdlwAABAAAgAAAABAAAAACAABAAAAACAAAAAEAACAAAAAEAACAAAAAEAAAAAIAAEAAAAAIAAAAAQAAIAAAAAQAAIAAAAAQAAAAAgAA2BZXLsFuMIHXbOT14b3UdpLZdsp+c9uW7HvMtixRvXUjZFnwTQmfIwRADEgBThztIf+4a8b1IgU4lcUH864jrgABgPBcY4QAAYD4XHPEAAGA+NwHxAABgPSAFGEC6AWA/Ge9V9wvHADE597hCHAAkJ/7CHAANBjuKW4AAYD03GdBDEgBID8wCACA/Nx/BICbD2gH1AC44aB1EWiqLtBBfgDaxRXiAxBtJ6d3Ax3kB6DddtNxEwFot/1cuXEAFLel06UEHeQHoN121Z3wBkF+gAg0KAAQH9DWSAEAQARaEwCiP6DdNSoAkB/s3f6qbYNXiA9Au7hCfiyrhB8Qyso5066tRQAgf23Xx0zYDwKBA4D8DV8LgyhEr4tFAECLwocoVCYCV0jA+W54HhYROBYYCAT5tz4vw33EAUCIdp2NPmfbyLlaBAByQPz8NbAnP8/DnV8HQQApQru4Qn7OiYi5CQ55Lh1EIaohmu2CXgAaMAKKAEAYzoXrSQ0A0EipDax57PQCnJQ82FTaCg6gYfKDfa87k5AqdgAQCLTQhugGxPYD2hIpAI1tv+O1kl4VqPbpvEZIBxAAyB89RrPQNhYROEljttZCpDqP90jHc0TCcUwHdgCQ/7zHYw92TLiBgwkAxZpzX7OjTfElJaAGUCXxzrYkmEUEjgcmA+FUtryeLQvqIQXoCqkQHXJzHACNe99I1eKgItPIdyIAgEaJCCAANEiifuo6mJOLwCHv9bXlk9+R+Hucn80cwxEeELplfYBaxEYCQJQ7hsiYmdvYDUlDt91WDWXlocAGYm7yHXteZ1vpvs/8PdQAGhCYPXLnrcXnTO6RcQCN2/IzH/eaw39JBxCA5q1/zesPHHF/iMwGNQDTKPlNI9dwL/trKzpWagCQn/xXlq1V0KtECoBIzbS4Y5YFO2I+v6ZlbyoduFbSgFuJ/mtGSTNzO7sQORiAQwoAViD/2t2CZuHv2Xv7rffdTDcg0X+bbc2BrqmdsT1OAAfQbOQ+06o/Z5tGbRAASArR1r/WrcyKbGI2YCtdNGYHkux9L+zE77Yjt7EzztWucJ9PnaJ0kLWKCFnzdTSV369Tg3EA5yH/1kObxzqCreb44wLGnNyCQ4HNCQhXWyRc+ljmNAa78OfmHM/ShLUH2cdhHQC2bftIbjb8bjtiW1vwOVvh/TulC6AbsD6hK62a7zX+nvkQDaYALdj/ta2/Wfn93OenNAQ70/Iu9ZmtLLfdefvDpgBgXXGZ+n6M5CZhc8c8DtxMfA/gAIj+C5PbBEi+xHXQk4BiC4Nu4QSmRNCjuYBTOgAenb0d+U3Be2bha1Gyv1C0txFh2voe4EJIAaoUITOS+ClrvzXJ/FQit6Q48/sRgKZFIhVZpwhB7H+b+b5c1I7twye4CRAvt9hICVGPQOapx8CqwI1Ec7OgEJgZdt9ExCRV6Ivtz8rnLuMQ0fV7w99GRB6ZcwwtMEK03rpxL1AEPHMNYOlJOGOJbBbc1mYEQKTs8WCh4p9+rfPIbyVeMCz5e4loeoSRgTiAysi/9rFNIb8ZsX3ovVzPgIkQOmTlBzF5uL+HyP/q/h626yW8HqGNpBRLLT12xPt/uHM6mwPYM/qP7a4bIwJmpnBMvTY+GbXNF4/8IiI39/9Fvd8nXMQcN4ALwAFU605KCb/E50wkApUO+PELejrH7xzZjYh8cn8/OdLfJF74M5F6QswZUBc4qACYBsi6FdnnEDu3fxOw86UCYAPf27vfV/f7oyP+r1wK0EdqEKWOI/banIIhQnJSB2AOTP5czl9q1U1mu9D7XeJzNrCNH5ljbqB3fz+5/38Wka/cz08ics/k9bmuwNSxhEY7TlmpyC7YTtYaxXjYGoA5KfHH7rOUyCWvTXUGpvC9lIjEGqoe/quJ+HDkFxf5f+si//fK9ot8OXR4QB/I8VM9C2NqA3vWBexZBeCs3XwmYTuXjPC5wTxjbH6qqh97z++/N5EcW0d333YPP70jv3U5/zdu/987YbABETHe9iUEt4Hj6BOfW4Joa88bqE4AzAlIvuS+S7rPplbtY+91hQJgIta/C6QCXYBQEhADn7RW3qr7ry7y9yLyoyccvfreixOGWyaSx0TgIu8HGd0zArIkqdfoNbAIwPb7t7LuKr5jo/iYSG9GCECs6Oe7gM6L9qEcv1PE792P7tr74Ej90duXcelA5xzCTd66CkPEtRnbf/VEadjf1Ai753z+QwrANXPAphKSL3EMUz9XMl6/hMgyMb/vPLKbQMS/qHs6/N/Ll4N6dJQ3irxPavsPjtx3tZ+r2++zvPUE3OWtp8AGLHxqTQLfrWhH088g6dxFUExtOf7cGoDZmeBrfN8SKcASFt9MFIDYM/o6L8JbZcUHIg7keVaR3XdLg22/S7g775Nn+S/ux7oIPdj2myL+PRPpY7+HQUWDy7iNKBIeoTAYczxVOACTIYyd6RKO+EinUsGbWugzhe9LwtbHRMB//erZ/qsj/jBg56qitIkU3J696H3zRMUn5tVzGlpE9AjCGBlCMwgfKvUoHVtgR7YHO6H92AltqkoBkEzRpWTud0l/s5lBypLn2puZNzXX52wzx5OrU4xxEykR0Lb5WR3LIAADaZ899zC89uoI/UERsFOWX/cYPNT3GEXUm/u8n370kfsdW3HIRK5NydiBKSTda0zBoYuApUtCP3kNMCUMKZL2I+xdTAhK59rHonmqoYlHtpJBOLHusZiIpQYDhYjfeSlAp+zzi9rm2f0/EPwXVfQbPv+9cg+vitR3ed8joK/NIAbWKzo+PKEwnsuI7a+kQFg6dmCuzV+qcGgL6heHKwKOwQdVLArZ2NAN670b3ns/NtJIcgtopPrIQ0SPdbfZADG7iABo4kngmG2BENjCFMs/Hv1zUXnzQMQXlfc/i8ivlTh8Un//IJ9H9F2cOAzvPyJOrvcchp/zG891DGLyGOEYSwhmCt63mTY5xTmWBrXDuoQtngwUG8d99XLG1I0ZU4y0ATuYW47KZN7T9nYofPWq4BVCJ/Ght533OyYy/iCeLiJwXUSQLuq1F/ncdy8i8rUjpjjS/9p95jv394/yuYvvZ0XWgdiPiLDpWoNfGBxSgrtXHCwRydz7pY5hTGBbukvRevWMUwrAWJF4EZF/ks/dRjZCJFtY+Em9PjZXTI2Se5LPo99+5UjyQ4DcKdfRJeoEsYp/KHrFBMDv9ruogt8QjX/nSP737rPfisg/iMhfROQ3IvI3JwTfuRTgoX6HqvnGcz6DUOhtHoHUznq22CZ+St7vM1X3koVN5hDd1igAW08G0hfpFxH5T3nrQ5bIjdXkuarIYiOWXTI2O1d0CzmAwTr/q4qMw7X7bwmPuCvpuov932VIbgKfvaiIfwmQ/8UJ2N2la38QkX92RL+4yPxnJwhXVSO4e0TtlY3v1f8+0UME7CNRu4+QNjb8tzTal6xhONeml6YtrAgUuSiPSBTw0ataw+/k/eCUmHPoI/m5LkKZzM/w2X9xUfOh9n11juCHRJHwEoj81nMOsRqDCdQoLgnR0KR/UkW/Dy63/9pF+9+LyB9F5N/cPm4i8icR+Q8R+TtXCPzWOYJXJwS/uM/pyH4P1G1CtZte3Wv9/3Bed3k/zLePFFBTswBNRHRMgqy2oOidK4aXFMsPO23+CNOB+xFicXNW9W+quGQjN7MLRAuTyPtNokh0d5H/f+R9v/aTiPyXcwRPEbdhAjY5Vsk3keLkJfA5v/DXeS5p6PZ7ciLwtUtbfnIk/oMSgIeI/LtzZN+KyP+KyF/dOev8/RGI8qHag1/QFVUzGbbVRcNLoLdgiScOTYnsY9PMuTWy5gVgCu4Jqx8j4EXlxr3nPEoKmH91NQtR9YAf3E/nVb51tH5W19mo6Gk90vQe6TtPvPQ6e10k6mkn8OR+vnLFv2+cCHzjiP97R/AXdzx/dE7hT+r8fnTi9knexgdoMQhZ+4sXsW9KOO6eQ+gC7s9E0oHSPHvqCMGpdYDSguFp1gM4knj5w1k1yUuKgTHyx9bU/9qlHy8ukn7rGvYl4SRi9QCJOIMxeb/f56//vioh+MpLA37rCoFDWvNn56x+cr+/U07h7pG39+oCoXX/TCDNC7kHvbbgTTkd69UXSscFLL2GwFKPPKMXYKUeBRsRhq7Qdo0d+vtQNvum/k5V8kXy8/hNwXtdpvJvItX/QRh+44Trqn7/o7yN8PuL2/bVRf4fVb5/84p8oQbee7WVR6K4F6rg+5OUxBObUrLnBgOVvh6rH0wp9CEAC6NL2KpLRgBsJEUIFZNSS27lXjMybqKPSH4gk+8YYgORtBhcXeQfXvvKNcRBEG4uTflZEf6jI99g+3Wxto9E/j5yHaznAvxegtDUX/36wxMXmUD+tbv5Sj7fywFHApbMBiwZgltSEZ2rNP4gmkdCHC6JQpwWCF2Z1sOQL/Ll4J9QRNdRVr/nT4KRTIoggbTAL1bqxTFyXYdD7WGI9Hd5Pzjn6lIBPWX35my/9SKvtv8iX/bn+0N6tW3vI2Lpk9tGHEBuEZAlB/8sRfSUA6hKALrCKn03wlI/ZgrAxdtXzgFIJvpaKeveMQUkjo03SE3w6QochHjRXuTLkYT+MQzdgHoMQ6eE5CqfBzN9lPdDde+u4Nd5lt+o//2uVD1Wog+4glidIESQa8Q1yAjCh4Zbx+z9VlOFqxaAXAVzzHPo+5kC0GUEpZP40NyptYDSImEJiUtTAJHx03/93o6BnE+R958c2Z/VZ2+qDtDJl4OABiG4K+ej74PxXNVdwkuLpYp6xnMaYxcMtRPJuvZagtVNBlqCPEuRP4aLhBegHHtsY4o/sYklsX2UDF5JuYbUQKeQS+hVsfJJ3s/57zwrfwvk2yLv++S10xomFX2UzwODRN4GHIln13Wt5iHpIb4+SWwkWk9ZPThFWCOVL+u9pgMorYCWOIAl+kHNxOg+VQhy2y617PcY95ByBX534iWQbnSKtHqtv1A1/+7VQYbU4SHv1wh4Vfsc1hD45LkHX2RsoKA3JcfX4tonhHLL6b+xfVW1KKgpOCGz8UXtdiD5mMLnnLX9ZURq0CX2o3sD/AlWF08IdMFziPqdIn4v7xf0HHL0XtUJXpRY3Nx7H+RtYZFXz034XX9LWfwptt8uTPDSOsDhBWDpIYt2ARLutezYlCXCpkT/XJ1AJD9+IFcj0EVAfyVfo6L8Q8Jde9oJWEX4F+UoHi41sK7IKBIeNZiawZey81Nt/xKEX2L7wwvA1uQ3K4vPFkIw91kAsbEEJcXD0hShy9RJQsuBGyUGfkG4U8XCIY14Ufn+MGloSBt0QfAi4R4DI9Oq/Kl2xnMBFk4B1haANUm8pquY+4DPkuhfmiLkBiN1CQHwG6teGly8dGCoOehVgp9VneBVkbwLpBVG8j0CYxzAXPKu/WQgkcoeDLIE8ZaeInkkh5BbqivncKYKwFiBMIFiYKie46+kFCug+f8PvQJ6QNXQK6BHEYaeQaAHS5mJYnA04tuNRWZ1AZhDFrsBkfd2Bks9JDRFZDtSBHI1hLH5cmx9hsFNPMnbAqPD56/KQfhjAGLrJk7J9fcmfXNPBx5DFrsRafcWgtyKQnNcQAn5UwIQ275UBDp56/bTdQJdNxiKg3f5srB3kfdDhmUG4W2FxD+1AEwRgSM++HMtNzCV/Nqql6QIY7aNCUBqUJJfJOxULv9Qef/wuj98Vw8rn5rvH4mAR6kxVCEAm57PAdOBnNUfWz/I9R7YAqEJbR9ahlz3/9/lfQFRFwh9UUg9CzA3b3+t6v6Wuf6pawAIwLTPj6kBlFh4GUn4sefkr0Y0zAO4eimBv7KPPwtyLMnXeuz33g7gkAJQ65JgNcJm8u/QCrYpMhgpf1xb6XuxxqpXPRrs/T3wmpV0f/4S5D8F8RCA85LczBSC0n3lhmXbjN03I49F5/xDKqDTgtIuvLkVfchMCrD58ZgVPj/1mYVj35t6HiFx6CQ+rbWkgLdEP36t+T81gIZqAXNFIEXqHNnNCtfDdxOpAt8Yy79V9Cf/X1EAEIFtRGBMtF9KBMYuoLnmmnxTSLTF8N6qBYAaQJ11hlDePmY8Ru5hqSkS595fa/y7PdC1nxpA6AVokKxmxmdSzy5IrVxUKgwlkTlH6DnRnYIeAgCkvOJf8iz6EpJtkYvvHfkRFwRg82i+lLWf+pm56yFuRXy7wb2qYZ8IQGWEnbJPO5KQc9OGXIM1KzX4NWbFEcVXxpJPBjrqI5CPNPNwjQVQ9r7u9gCfrSH6H1LMuoNdpBbSiDX2ucdyUxby148O0m2+T7sSwbYUA3sQoajKbVMDAFNqCXZiA9KDc8xGZMcVVobrjg27JRLv9X2xvnyTIajZifhHExuLAIC1RGAOoedaSnswAluISg2gtjrAUsd1hoEu9oTkb0JUWnIAa1n2qTn6Unm+LOQK9iAIkX9nLDkOYK+GeJRjMyfdzxqEO3q/ejP1BGoAx3MYS+5nriC0OKimKVexlgM4sgswlex/i+XTt2zstUwLbkpcWikC+jfBNt7Qtxw5aOVcawKcCteVb7xp9LoeycbveQ1qvG9NoZN2UeuUVNvotT2LI2rGAbQUqbfe/xJdj+TNoGkHcBZy7B29IH/F57JmL0BNeavhew7XmO3JiNmsACACx7sea08GqoUo9sTndqgUgDzuWNcjlzbYBq4JbZIawChS1P59NQiihfwIAG4A0eV6IwDNEdJyncHW2KoI+P/fV9v1afS7EdhGRK9r/QJAlFPbfe5nBkwHLrtpptHvJ+ou6+h4OKjUOUlo72O2laQIluOpCx03Bku5kLWH/BXiuvMNqm16q6moka89Ccke/F4BagBNi1aOBKYgvbAVEgzyIwCbNDBzkvM4E4kgfyU1gDPcMIbyQv7qj2/rgUAllrRGGPgHqWo8XoYC42S45qQA3FCOn2uNAADqApAfAeDmIgRc0zZAN+A2gkaRkKCAA2j4htOIifgWAUAEsLEIJinAiEbQwqIYBrJzjjgAIgHkBwhAg42k1dTAcp6kAKQD6cZiIALnjAC0JQKhBmSkzvUTSG8QALBgYzp68ZCcvrLrcK30wjKwpnzBDwgO8XEANMaoQBzxAaFgIxxpPYDRx87tA0T/eegqv+BEKAD5GxUA8lJA+0MAAID8rQsA6QCA/DgARADQzlpPARABgNNsvAaACADaVMMCQF0AQP7GBQA3AAgiCAAiAGgzrQsAKQGA/I0LAG4A0D48XBu/yUwoAk0Hho6bDmgD7bYD5gJQGyAANAwEgMbA/UYAAI0Cx9ciWBIsLwIUChF2HACNBwAEABEA2H1SgKZFgJQAsUYAaGDUCCA9KQCg8XH9cQA0QtwApMcBABomwAEgAl8AZ4CoIgCNN2JTKBCp96c8x2/utmvtd+q2YEHU/GxAAAA1AAAAAgAAQAAAAAgAAAABAAAgAAAABAAAgAAAABAAAAACAAACAABAAAAACAAAAAEAACAAAAAEAACAAAAAEAAAAAIAAEAAAAAIAAAAAQAAIAAAgKPj/wYA8pXMGRPFa1wAAAAASUVORK5CYII=',
			df_p3: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkM0MjMwNzJFQkY2RTExRTdBRkQwODA5QTE1NzEyOEQxIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkM0MjMwNzJGQkY2RTExRTdBRkQwODA5QTE1NzEyOEQxIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QzQyMzA3MkNCRjZFMTFFN0FGRDA4MDlBMTU3MTI4RDEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QzQyMzA3MkRCRjZFMTFFN0FGRDA4MDlBMTU3MTI4RDEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4n6pLqAAAogUlEQVR42uxd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',
			df_p4: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjA2QjRGN0VCQkY3MTExRTc5MzU0QkUzQjU2MTlCRkI4IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjA2QjRGN0VDQkY3MTExRTc5MzU0QkUzQjU2MTlCRkI4Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDZCNEY3RTlCRjcxMTFFNzkzNTRCRTNCNTYxOUJGQjgiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDZCNEY3RUFCRjcxMTFFNzkzNTRCRTNCNTYxOUJGQjgiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6bPVnoAAAOrklEQVR42uxd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',
			df_l1: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAGtSURBVHja7N2BkcIwEARBZJR/yCx5eHozkGnvneCr/mz7SDdP+fDbzrYDQDen/gyuBmznagBvQHoNqCN4vAAeQD3pBrAEAqABPQDPwOHD898tAAAAygCMALcAAIwAAAAAoHn+LwAaAIA4AgA0AADV8/seIN4AAMTPbwTYAQAwAgAwAgDQAADYAQAAAIDU+Y0AOwAARgAAAoAdAAAjAIAiAgDC5wdAAwCgAQDQAAC4BQAQBOB7APUPgBEAgBYAQAMA4O0HAAIAjAAAAABAABAAjAAAAABAABAAjAAABAANAIAAIAAIAC/YAfxRaDjTADIAAABAABAABIDe/LcDAACAACAAGAEACAAaAAABQAMAIABoAAAAAOD9CADQAAAIALn8NIARAIAWAMANAAAjAAAAAAAAAAAASAFwC9AAAAAAAAAA2AEA0AAAAABAJn4O1gB2ACMAAA0AgB0AACMAACMAAA0AQGsH0AAaAAA7QDTXCPA/gwQAI8AI6I4ADeAWAAAAAAAAgCUQgOASqAE0gGtgGYBrIAQA2AEA0AAAaAAANIBbgA8/lD8AAAD//wMA3tBqDKwrcxcAAAAASUVORK5CYII=',
			s1: 'data:image/png;base64,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',
		},
		outerGlow: {
			glowColor: "rgba(22,71,121,.9)",
			size: 1,
			perTime: 2,
		},
		controls: {
			enablePan: false,
			enableZoom: true,
			enableRotate: true,

			enableDamping: true,
			dampingFactor: .1,
			panSpeed: .1,
			zoomSpeed: .1,
			rotateSpeed: 0.013,
			distance: [240, 460],
			polarAngle: [Math.PI * .24, Math.PI * .36],
			azimuthAngle: [-Math.PI * .5, Math.PI * .5],
		},

		background: {
			color: '#ffffff',
			opacity: 0
		},
		// 相机参数
		camera: {
			fov: 55,
			near: 8,
			far: 10000,
			position: [0, 298, 198]
		},
		light: {
			Ambient: {
				color: '#FFFFFF',
				strength: 1.0
			},
			isHemisphere: false,
			isDirectional: true,
			hemisphere: {
				color: '#EFEFEF',
				groundColor: '#EFEFEF',
				strength: 0.7,
				position: [0, 0, 200]
			},
			directional: {
				color: '#1A1A1A',
				strength: 1.0,
				position: [75, 100, 75]
			},
		},
	};

	//-init
	function initiate() {

		thm.WHRatio = new THREE.Vector3(1, 1, 1);
		thm.svgOffset = new THREE.Vector3(0, 0, 0);

		thm.scene = new THREE.Scene();
		df_Clock = new THREE.Clock();

		var wh = getWH();
		df_Width = wh.w;
		df_Height = wh.h;
		var cm = df_Config.camera,
			bg = df_Config.background;

		thm.camera = new THREE.PerspectiveCamera(cm.fov, wh.w / wh.h, cm.near, cm.far);
		thm.camera.position.set(cm.position[0], cm.position[2], cm.position[1]);
		thm.camera._position = thm.camera.position.clone();

		// renderer
		thm.renderer = new THREE.WebGLRenderer({
			antialias: true,
			alpha: true
		});
		thm.renderer.setPixelRatio(Math.min(1, window.devicePixelRatio));
		thm.renderer.setSize(df_Width, df_Height);
		thm.renderer.setClearColor(bg.color, bg.opacity);

		// controls
		_Collects.handleControls();
		thm.controls = new THREE.OrbitControls(thm.camera, thm.container[0]);
		setControls(thm.controls, df_Config.controls, true);

		// lights
		setLight(thm.scene, df_Config.light);

		thm.container.append($(thm.renderer.domElement));
		window.addEventListener('resize', onContResize, false);

		// mouse event
		df_Mouse = new THREE.Vector2();
		df_Raycaster = new THREE.Raycaster();
		thm.container[0].addEventListener('mouseup', onDocumentMouseUp, false);
		thm.container[0].addEventListener('wheel', onDocumentMouseWheel, false);
		thm.container[0].addEventListener('mouseout', onDocumentMouseOut, false);
		thm.container[0].addEventListener('mousemove', onDocumentMouseMove, false);
		thm.container[0].addEventListener('mousedown', onDocumentMouseDown, false);
	}

	//-shader
	var _Shaders = {
		SplineVShader: [
			"uniform vec3 u_color; uniform float u_opacity; uniform float u_width;",
			"attribute float cRatio; attribute vec3 cPosition; varying vec4 vColor; ",
			" varying vec2 vUv; void main() { ",
			"vec3 nPosition = position; float k = 20.0;",
			"if ( cRatio>.0 && cRatio<.5 ) { nPosition.y = u_width; } ",
			"if ( cRatio>.5 && cRatio<1.5 ) { nPosition = cPosition*u_width+position; } ",
			// 2
			"if ( cRatio>1.5 && cRatio<2.5 ) { nPosition = -cPosition*u_width/2.0+position; } ",
			"if ( cRatio>-2.5 && cRatio<-1.5 ) { nPosition = cPosition*u_width/2.0+position; } ",
			// 3
			"if ( cRatio>2.5 && cRatio<3.5 ) { ",
			"nPosition = -cPosition*k+position; nPosition.y = u_width/2.0; } ",
			"if ( cRatio>-3.5 && cRatio<-2.5 ) { ",
			"nPosition = cPosition*k+position; nPosition.y = -u_width/2.0; } ",
			// 4
			"if ( cRatio>3.5 && cRatio<4.5 ) { ",
			"nPosition = -cPosition*k+position; nPosition.y = -u_width/2.0; } ",
			"if ( cRatio>-4.5 && cRatio<-3.5 ) { ",
			"nPosition = cPosition*k+position; nPosition.y = u_width/2.0; } ",

			"vColor = vec4( u_color, u_opacity ); vUv = uv;",
			"vec4 mP = modelViewMatrix * vec4( nPosition, 1.0 ); ",
			"gl_Position = projectionMatrix * mP; } "
		].join("\n"),
		SpreadVShader: [
			'uniform vec3 u_color; uniform float u_opacity; uniform float u_time; ',
			'attribute float cRatio; attribute vec3 position2; varying vec4 vColor; ',
			'varying vec2 vUv; void main() {',
			'float _k = cRatio + u_time; ',
			'if ( _k >= 1.0 ) _k -= 1.0; ',
			'vec3 vPos = mix( position, position2, _k );',
			'vColor = vec4( u_color, u_opacity*5.0*(1.0-_k) ); vUv = uv;',
			'gl_Position = projectionMatrix * modelViewMatrix * vec4( vPos, 1.0 );',
			'}'
		].join("\n"),
		SpotVShader: [
			'uniform vec3 u_color; uniform float u_opacity; uniform float u_size; ',
			'uniform float u_time; attribute float cOffset; varying float vTime; ',
			'varying vec4 vColor; void main() { vTime = u_time + cOffset; ',
			'vColor = vec4( u_color, u_opacity ); ',
			'vec4 mP = modelViewMatrix * vec4( position, 1.0 ); ',
			'gl_PointSize = u_size * 300.0/(-mP.z ); ',
			'gl_Position = projectionMatrix * mP; } ',
		].join("\n"),
		PointVShader: [
			'uniform vec3 u_color; uniform float u_opacity; uniform float u_size; ',
			'uniform float u_time; uniform float u_len; uniform float u_ratio;',
			'attribute float cSize; attribute float cOpacity; attribute float cId; ',
			'varying vec4 vColor; void main() { float _k = u_ratio + u_time; ',
			'if ( _k >= 1.0 ) _k -= 1.0; ',
			'float _m = u_len*_k, _l = 108.0, _o = 1.0, _s = 1.0; ',
			'if ( cId >= _m-_l && cId <= _m ) { ',
			'	float _n = 1.0+(cId-_m)/_l; ',
			'	_o = 3.6*_n; _s = 2.0*_n; } ',
			'vColor = vec4( u_color, u_opacity * cOpacity *_o ); ',
			'vec4 mP = modelViewMatrix * vec4( position, 1.0 ); ',
			'gl_PointSize = _s * u_size * 300.0/(-mP.z ); ',
			'gl_Position = projectionMatrix * mP; } ',
		].join("\n"),

		SplineFShader: [
			"varying vec4 vColor; void main() {  gl_FragColor = vColor; } ",
		].join("\n"),
		SpreadFShader: [
			"uniform sampler2D u_txue; varying vec4 vColor; ",
			"varying vec2 vUv; void main() {  gl_FragColor = vColor * texture2D(u_txue, vUv); } ",
		].join("\n"),
		SpotFShader: [
			"uniform sampler2D u_txue; varying float vTime; varying vec4 vColor; ",
			"const float pi2 = 6.2831853071795866; void main() { ",
			"float c = cos( vTime * pi2 ); float s = sin( vTime * pi2 ); ",
			"vec2 rotatedUV = vec2( c*(gl_PointCoord.x-.5) + s*(gl_PointCoord.y-.5) + .5,",
			" .5 -c*(gl_PointCoord.y-.5) + s*(gl_PointCoord.x-.5) );",

			"gl_FragColor = vColor * texture2D( u_txue, rotatedUV ); } ",
		].join("\n"),
		PointFShader: [
			"uniform sampler2D u_txue; varying vec4 vColor; void main() { ",
			"gl_FragColor = vColor * texture2D( u_txue, gl_PointCoord ); } ",
		].join("\n"),
	};

	//- Common methods
	var _Collects = {
		obj: function () {
			return new THREE.Object3D();
		},
		color: function (c) {
			return new THREE.Color(c);
		},
		setMulti: function (arr) {
			return new THREE.MultiMaterial(arr);
		},

		//-	
		creatCGeo: function (p) {
			return new THREE.CurvePath().createGeometry(p)
		},
		tgShape: function (c, h) {
			return THREE.ShapeUtils.triangulateShape(c, h);
		},
		Matrix: function () {
			return new THREE.Matrix4().makeRotationX(_Tdata.M_PI2);
		},
		reverse: function (c) {
			if (!THREE.ShapeUtils.isClockWise(c)) c = c.reverse();
		},
		clamp: function (v, mi, ma, df) {
			return Math.min(ma, Math.max(mi, isNaN(v) ? df : v));
		},
		limit: function (v, arr) {
			return (arr.indexOf(v) != -1) ? v : arr[0];
		},

		//- easing
		easing: function (k, func) {
			if (isFunction(func)) return func(k);
			else return k;
		},
		ease1: function (k) {
			k *= 2;
			return (k > 1) ? 0.5 * k * (k - 2) + 1 : 0.5 * k * (2 - k);
		},
		ease2: function (k) {
			k *= 2;
			return 0.5 * (--k * k * k + 1);
		},
		ease3: function (k) {
			return k * (2 - k);
		},

		//- opacity traverse 
		opacityTvs: function (obj, val) {
			
			val = isNaN(val * 1) ? 1 : val * 1;
			obj.traverse(function (child) {
				if (child.material && child._opacity) {
					if (!child.material.uniforms) child.material.opacity = child._opacity * val;
					else child.material.uniforms.u_opacity.value = child._opacity * val;
				}
			});


		},
		colorHight: function (obj, val) {

			obj.traverse(function (child) {
				if (child.material && child._hover_color) {
					var _p = child._hlOpacity || child._opacity;
					var color = val == 1 ? child._hover_color : child._color;
					if (!child.material.uniforms) {
						child.material.color = color;
						child.material.opacity = _p;
					} else {
						child.material.uniforms.u_color.value = color;
						child.material.uniforms.u_opacity.value = _p;
					}
				}
			});


		},
		colorTvs: function (obj, isHL) {
			obj.traverse(function (child) {
				if (child.material && child._hlColor) {
					var _c = isHL ? child._hlColor : child._color,
						_p = isHL ? child._hlOpacity : child._opacity;

					if (!child.material.uniforms) {
						child.material.color = _c;
						child.material.opacity = _p;
					} else {
						child.material.uniforms.u_color.value = _c;
						child.material.uniforms.u_opacity.value = _p;
					}
				}
			});
		},

		//- preprocessing
		handleTags: function () {
			var fs = df_Config.tags.fontSize * 1;

			df_Config.tags.fontColor = _Collects.getColorArr(df_Config.tags.fontColor);
			df_Config.tags.fontHover = _Collects.getColorArr(df_Config.tags.fontHover);
			df_Config.tags.fontSize = _Collects.clamp(fs, 1, 10, 3);
			df_Config.tags.fontWeight = (df_Config.tags.fontWeight == 2) ? 2 : 1;
		},

		handleTagsText: function (id, name, coord) {
			for (var i = thm.shapesArrLen - 1; i >= 0; i--) {
				var shi = thm.shapesArr[i];
				if (shi._path_id == id) {
					var shiC0 = shi.children[0],
						shiC0T = shiC0.children[3];

					var _txue = _Collects.creatTagsTxue(name),
						_s = _t._scale * df_Config.tags.fontSize;

					thm.SVGMapObj[id]['name'] = name;
					thm.SVGMapObj[id]['coord'] = coord;
					shi._name = shiC0._name = name;

					shiC0T.material.size = _s;
					shiC0T.material.map = _txue;
				}
			}
		},

		handleControls: function () {
			df_Config.controls.enablePan = (df_Config.controls.enablePan === true);
			df_Config.controls.enableZoom = (df_Config.controls.enableZoom === true);
			df_Config.controls.enableRotate = (df_Config.controls.enableRotate === true);
		},

		handleBlock: function () {
			var bc = df_Config.sceneStyle.blockColor,
				bh = df_Config.sceneStyle.blockHeight;

			df_Config.sceneStyle.blockColor = _Collects.getColorArr(bc);
			df_Config.sceneStyle.blockHeight = _Collects.clamp(bh, 1, 8, 2);
		},

		handleBorder: function () {
			var lc = df_Config.sceneStyle.borderColor,
				lw = df_Config.sceneStyle.borderWidth * 1;

			df_Config.sceneStyle.borderColor = _Collects.getColorArr(lc);
			df_Config.sceneStyle.borderWidth = _Collects.clamp(lw, .1, 5, 1);
		},

		handleGlow: function () {
			df_Config.outerGlow.glowColor = _Collects.getColorArr(df_Config.outerGlow.glowColor);

			df_Config.outerGlow.size = _Collects.clamp(df_Config.outerGlow.size * 1, .1, 5, 1);
			df_Config.outerGlow.perTime = _Collects.clamp(df_Config.outerGlow.perTime * 1, .1, 5, 2);
		},

		//-
		handleBlockHeight: function (opt) {
			opt = opt || {}; /* opt: { name: height,... } */
			for (var k in thm.SVGMapObj) {
				thm.SVGMapObj[k].height = 0;
				if (opt[k]) {
					thm.SVGMapObj[k]['height'] = _Collects.clamp(opt[k] * 1, -1, 1, 0);
				}
			}
			_Collects.setBlockColor();
		},

		setBlockColor: function () {
			var hlc, lhlc,
				bh = df_Config.sceneStyle.blockHeight,

				bc = df_Config.sceneStyle.blockColor,
				hlc1 = df_Config.sceneStyle.blockHLColor1,
				hlc2 = df_Config.sceneStyle.blockHLColor2,

				lc = df_Config.sceneStyle.borderColor,
				lhlc1 = df_Config.sceneStyle.borderHLColor1,
				lhlc2 = df_Config.sceneStyle.borderHLColor2;

			for (var i = thm.shapesArrLen - 1; i >= 0; i--) {
				var shi = thm.shapesArr[i],
					_h = thm.SVGMapObj[shi._name].height * bh;

				hlc = _h > 0 ? hlc1 : _h < 0 ? hlc2 : bc;
				lhlc = _h > 0 ? lhlc1 : _h < 0 ? lhlc2 : lc;

				shi.traverse(function (child) {
					if (child.material && child._hlColor) {
						if (child._isShape) {
							child._hlColor = hlc[0];
							child._hlOpacity = hlc[1] * child._optRatio;
						} else {
							child._hlColor = lhlc[0];
							child._hlOpacity = lhlc[1] * child._optRatio;
						}
					}
				});

				shi.position.y = _h;
				shi.children[1].position.y = -bh - 3 - _h;
				shi.children[2].position.y = -bh * 1.3 - 8 - _h;

				shi._position = shi.position.clone();
			}
		},

		handleTypeVisible: function (type, name) {
			name = name + '';
			for (var i = thm.shapesArrLen - 1; i >= 0; i--) {
				var shicc = thm.shapesArr[i].children[0].children[1];
				shicc.traverse(function (child) {
					if (child._isTags) {
						if (type == 1) child.visible = true;
						if (type == 2) child.visible = (name != child._txue) ? false : true;
					}
				});
			}
		},

		//- creatMapMesh
		getBevelVec: function (inPt, inPrev, inNext) {
			var v_trans_x, v_trans_y, shrink_by = 1;

			var v_prev_x = inPt.x - inPrev.x,
				v_prev_y = inPt.y - inPrev.y,
				v_next_x = inNext.x - inPt.x,
				v_next_y = inNext.y - inPt.y,
				v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y),
				collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);

			if (Math.abs(collinear0) > Number.EPSILON) {
				var v_prev_len = Math.sqrt(v_prev_lensq);
				var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

				var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len),
					ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len),
					ptNextShift_x = (inNext.x - v_next_y / v_next_len),
					ptNextShift_y = (inNext.y + v_next_x / v_next_len);

				var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
					(ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);

				v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
				v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);

				var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);

				if (v_trans_lensq <= 2) {
					return new THREE.Vector2(v_trans_x, v_trans_y);
				} else {
					shrink_by = Math.sqrt(v_trans_lensq / 2);
				}

			} else {

				var direction_eq = false;
				if (v_prev_x > Number.EPSILON) {
					if (v_next_x > Number.EPSILON) direction_eq = true;
				} else {
					if (v_prev_x < -Number.EPSILON) {
						if (v_next_x < -Number.EPSILON) direction_eq = true;
					} else {
						if (Math.sign(v_prev_y) === Math.sign(v_next_y)) direction_eq = true;
					}
				}

				if (direction_eq) {
					v_trans_x = -v_prev_y;
					v_trans_y = v_prev_x;
					shrink_by = Math.sqrt(v_prev_lensq);
				} else {
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt(v_prev_lensq / 2);
				}
			}

			return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
		},

		creatSplineGeo: function (contour, opts) {
			opts = opts || {};
			contour = contour || [];
			var type = opts.type || 0,

				u1 = (undefined != opts.uRatio) ? opts.uRatio : .4,
				v1 = (undefined != opts.vRatio) ? opts.vRatio : 1;

			var bgeo = _Geometries.buf();
			_Collects.reverse(contour);

			var il = contour.length,
				bevelVecs = [],
				r1 = -.1,
				r2 = .1,
				v2 = 1 - v1,
				u2 = 1 - 2 * u1;

			if (type > 0.5) {
				for (var i = 0, j = il - 2, k = i + 1; i < il; i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0;
					bevelVecs[i] = _Collects.getBevelVec(contour[i], contour[j], contour[k]);
				}
				r1 = -type;
				r2 = type;
			}

			var indices = [],
				uvs = [],
				ratios = [],
				positions = [],
				positions2 = [];

			for (var i = 0; i < il; i++) {
				var ci = contour[i],
					bv = bevelVecs[i] || new THREE.Vector2();
				bv = bv.clone();

				uvs.push(u1 + u2 * i / il, v1, u1 + u2 * i / il, v2);
				positions.push(ci.x, ci.y, 0, ci.x, ci.y, 0);
				positions2.push(bv.x, 0, bv.y, bv.x, 0, bv.y);

				ratios.push(r1, r2);

				if (i < il - 1) {
					var a = i * 2,
						b = i * 2 + 1,
						c = i * 2 + 2,
						d = i * 2 + 3;
					indices.push(a, b, c, b, d, c);
				}
			}
			indices.push(il * 2 - 2, il * 2 - 1, 0, il * 2 - 1, 1, 0);

			bgeo.setIndex(indices);
			bgeo.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
			bgeo.addAttribute('cRatio', new THREE.Float32BufferAttribute(ratios, 1));
			bgeo.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
			bgeo.addAttribute('cPosition', new THREE.Float32BufferAttribute(positions2, 3));

			return bgeo;
		},

		creatShapeGeo: function (contour) {
			contour = contour || [];
			var sgeo = _Geometries.buf();
			var i, l, indices = [],
				vertices = [],
				uvs = [];

			_Collects.reverse(contour);
			var faces = _Collects.tgShape(contour, []);

			for (i = 0, l = contour.length; i < l; i++) {
				var vertex = contour[i];
				vertices.push(vertex.x, vertex.y, 0);
				uvs.push(vertex.x, vertex.y);
			}

			for (i = 0, l = faces.length; i < l; i++) {
				var face = faces[i];
				indices.push(face[0], face[1], face[2]);
			}

			sgeo.setIndex(indices);
			sgeo.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
			sgeo.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

			return _Geometries.geo().fromBufferGeometry(sgeo);
		},

		creatOuterGlow: function (shapes, opts, isShow) {
			var sl = shapes.getLength(),
				len2 = sl / _Tdata.sl;
			var num = _Collects.clamp(Math.floor(sl / _Tdata.st), 2, 10, 4);

			//-
			var gGeo2 = shapes.createSpacedPointsGeometry(num * 3),
				gGeo3 = shapes.createSpacedPointsGeometry(len2);
			gGeo2.applyMatrix(_Collects.Matrix());
			gGeo3.applyMatrix(_Collects.Matrix());
			if (!df_pointMtl) {
				df_pointMtl = _Materials.point({
					color: opts.gc[0],
					opacity: opts.gc[1] * 1.4,
					size: 90 * opts.gs,
					depthWrite: false,
					transparent: true,
					map: _Tdata.txues._df_l1,
					blending: THREE.AdditiveBlending,
				});
			}
			if (!df_pointMtl2) {
				df_pointMtl2 = _Materials.point({
					color: opts.gc[0],
					opacity: opts.gc[1] * .4,
					size: 18 * opts.gs,
					depthWrite: false,
					transparent: true,
					map: _Tdata.txues._spot,
					blending: THREE.AdditiveBlending,
				});
			}

			//-
			var contour = shapes.getSpacedPoints(num);
			var gGeo1 = _Collects.creatCGeo(contour);
			gGeo1.applyMatrix(_Collects.Matrix());

			var _o = isShow ? 1.4 : 0;
			var outerGlow = new THREE.Points(gGeo1, _Materials.point({
				color: 0xF5F8FD,
				opacity: opts.gc[1] * _o,
				size: 54 * opts.gs,
				transparent: true,
				map: _Tdata.txues._df_p1,
				depthTest: false,
			}));
			outerGlow.add(new THREE.Points(gGeo2, df_pointMtl));
			outerGlow.add(new THREE.Points(gGeo3, df_pointMtl2));
			outerGlow.position.y = 4;
			outerGlow.children[0].position.y = -2;
			outerGlow.children[0].visible = isShow;
			outerGlow.children[1].position.y = 1;

			outerGlow._isGlow = true;
			outerGlow._optRatio = _o;

			outerGlow._color = opts.gc[0];
			outerGlow._opacity = opts.gc[1] * _o;

			//-
			outerGlow._flicker = true;
			outerGlow._transTimes = 0;
			outerGlow._perTimes = opts.gp;
			outerGlow._ratio = Math.random();

			return outerGlow;
		},

		creatSVGLine: function (lGeo, cArr, r, w) {
			var _line = new THREE.Mesh(lGeo, _Materials.shader({
				uniforms: {
					u_color: {
						value: cArr[0]
					},
					u_opacity: {
						value: cArr[1] * r
					},
					u_width: {
						value: -w
					},
				},
				transparent: true,
				side: THREE.DoubleSide,
				depthWrite: false,
				vertexShader: _Shaders.SplineVShader,
				fragmentShader: _Shaders.SplineFShader,
			}));

			_line.position.y = _Tdata.ry;

			_line._isSVGLine = true;
			_line._optRatio = r;

			_line._color = cArr[0];
			_line._opacity = cArr[1] * r;

			return _line;
		},

		creatShape: function (shapGeo, bc, r, hy) {
			var _shape = new THREE.Mesh(shapGeo, _Materials.lambert({
				color: bc[0],
				opacity: bc[1] * r,
				transparent: true,
				side: THREE.DoubleSide,
			}));

			_shape.position.y = hy;

			_shape._isShape = true;
			_shape._optRatio = r;

			_shape._color = bc[0];
			_shape._opacity = bc[1] * r;

			return _shape;
		},

		creatTags: function (name, opts, vec, pArr) {
			var obj = _Collects.obj(),
				pl = pArr.length;

			var _txue = _Tdata.txues['_' + pArr[0].txue],
				_size = _Collects.clamp(pArr[0].size * 1, 1, 64, 3),
				_text = pArr[0].text || [name],
				_offx = (pArr[0].offset || [])[0] * 1 || 0,
				_offy = (pArr[0].offset || [])[1] * 1 || 0,
				_tOffx = (pArr[0].textOffset || [])[0] * 1 || 0,
				_tOffy = (pArr[0].textOffset || [])[1] * 1 || 0,
				_color = _Collects.getColorArr(pArr[0].color),
				_mouseEvent = (pArr[0].mouseEvent === true),

				_vec3 = vec.clone().add(new THREE.Vector3(_offx, 0, _offy)),
				_tVec3 = _vec3.clone().add(new THREE.Vector3(_tOffx, 0, _tOffy));

			//-
			var tGeo = _Geometries.geo();
			tGeo.vertices.push(_tVec3);
			var txue = _Collects.creatTagsArrTxue(_text);
			var _s = txue._scale * opts.fs;

			var _tags = new THREE.Points(tGeo, _Materials.point({
				size: _s,
				color: opts.fc[0],
				opacity: opts.fc[1],
				map: txue,
				transparent: true,
				depthWrite: false,
				sizeAttenuation: false,
			}));
			
			_tags.position.y += opts.fs * 3;
			_tags._isTags = true;
			_tags._txue = pArr[0].txue;
			_tags._text = _text;
			_tags._color = opts.fc[0];
			_tags._hover_color = opts.fh[0];
			_tags._opacity = opts.fc[1];

			_tags.__vec3 = _vec3;
			_tags.__tVec3 = _tVec3;
			_tags._visible = _tags.visible;

			_tags._hasChild = false;
			//-
			if (_txue) {
				_tags._hasChild = true;
				var _spread = _Collects.creatSpread(_color, _vec3, _size);
				var _spot = _Collects.creatSpot(_color, _vec3, _txue, _size * 3);
				_tags.add(_spread, _spot);

				//-
				var lGeo = _Geometries.geo();
				lGeo.vertices.push(_spread.position, _spot.position);
				var _line = new THREE.Line(lGeo, _Materials.line({
					color: _color[0],
					opacity: _color[1],
					transparent: true,
				}));
				_line.position.copy(_vec3);
				_line._isLine = true;
				_line._color = _color[0];
				_line._opacity = _color[1];
				_tags.add(_line);

				//-
				if (!df_LableMtl) {
					df_LableMtl = _Materials.basic({
						transparent: true,
						depthWrite: false,
						side: THREE.DoubleSide,
						opacity: 0
					});
				}
				var geo = _Geometries.plane(16 + _size, 16 + _size);
				geo.applyMatrix(_Collects.Matrix());
				var _label = new THREE.Mesh(geo, df_LableMtl);
				_label.position.copy(_vec3);
				_label.position.y += 1;
				_label._isLabel = true;
				_label._text = _text;

				_tags.add(_label);
				if (_mouseEvent) thm.mEventArr.push(_label);
			}

			return _tags;
		},

		creatMigLine: function (cArr, vec1, vec2, h) {
			h = h || 28;
			var _l = vec1.clone().distanceTo(vec2.clone()) / 680;

			var curve, clen, vecs = [],
				lGeo = _Geometries.geo(),
				_h = new THREE.Vector3(-30, _l * h, 0),
				_h2 = _h.clone().multiplyScalar(0.5),
				_m = vec1.clone().add(vec2.clone()).multiplyScalar(0.5).add(_h),
				_m1 = vec1.clone().add(_m.clone()).multiplyScalar(0.5).add(_h2),
				_m2 = _m.clone().add(vec2.clone()).multiplyScalar(0.5).add(_h2);
			vecs.push(vec2, _m, _m1, vec1);

			curve = new THREE.CatmullRomCurve3(vecs);
			clen = Math.max(1, Math.floor(curve.getLength() * 1.3));
			var _vArr = curve.getSpacedPoints(clen);

			lGeo.vertices = _vArr;
			lGeo.computeLineDistances();
			var _Mline = new THREE.Line(lGeo, _Materials.lineD({
				color: cArr[0],
				opacity: cArr[1],
				transparent: true,
				depthWrite: false,
				dashSize: 6,
				gapSize: 5,
			}));

			_Mline._type = 4;
			_Mline._isMLine = true;
			_Mline._color = cArr[0];
			_Mline._opacity = cArr[1];

			//-
			var pGeo = _Geometries.buf(),
				pArr = [],
				sArr = [],
				oArr = [],
				idArr = [];
			for (var i = 0; i <= clen; i++) {
				pArr.push(_vArr[i].x, _vArr[i].y, _vArr[i].z);
				sArr.push(1);
				oArr.push(0.1);
				idArr.push(i);
			}
			pGeo.addAttribute('cId', new THREE.Float32BufferAttribute(idArr, 1));
			pGeo.addAttribute('cSize', new THREE.Float32BufferAttribute(sArr, 1));
			pGeo.addAttribute('cOpacity', new THREE.Float32BufferAttribute(oArr, 1));
			pGeo.addAttribute('position', new THREE.Float32BufferAttribute(pArr, 3));

			var _MPoint = new THREE.Points(pGeo, _Materials.shader({
				uniforms: {
					u_len: {
						value: clen
					},
					u_ratio: {
						value: Math.random()
					},
					u_txue: {
						value: _Tdata.txues._df_p4
					},
					u_time: {
						value: 0
					},
					u_color: {
						value: cArr[0]
					},
					u_opacity: {
						value: cArr[1]
					},
					u_size: {
						value: 6
					},
				},
				transparent: true,
				depthWrite: false,
				blending: THREE.AdditiveBlending,
				vertexShader: _Shaders.PointVShader,
				fragmentShader: _Shaders.PointFShader,
			}));

			_MPoint._isMPoint = true;
			_MPoint._color = cArr[0];
			_MPoint._opacity = cArr[1];

			_MPoint._flowPoint = true;
			_MPoint._transTimes = 0;
			_MPoint._perTimes = (_l + Math.random() * 0.4) * 8;

			_Mline.add(_MPoint);

			return _Mline;
		},

		creatSpread: function (cArr, vec, s) {
			vec = vec.clone();
			s = s * 3.5 || 28;
			var sGeo = _Geometries.buf();
			var indices = [],
				ratios = [],
				vecs1 = [],
				vecs2 = [],
				uvs = [];
			for (var i = 0, num = 3; i < num; i++) {
				for (var j = 0; j < 4; j++) {
					vecs1.push(vec.x, vec.y, vec.z);
					ratios.push(i / num);
				}
				//
				vecs2.push(vec.x - s, vec.y, vec.z - s);
				uvs.push(0, 0);
				//
				vecs2.push(vec.x + s, vec.y, vec.z - s);
				uvs.push(1, 0);
				//
				vecs2.push(vec.x - s, vec.y, vec.z + s);
				uvs.push(0, 1);
				//
				vecs2.push(vec.x + s, vec.y, vec.z + s);
				uvs.push(1, 1);

				indices.push(4 * i, 4 * i + 2, 4 * i + 3);
				indices.push(4 * i, 4 * i + 3, 4 * i + 1);
			}
			sGeo.setIndex(indices);
			sGeo.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
			sGeo.addAttribute('cRatio', new THREE.Float32BufferAttribute(ratios, 1));
			sGeo.addAttribute('position', new THREE.Float32BufferAttribute(vecs1, 3));
			sGeo.addAttribute('position2', new THREE.Float32BufferAttribute(vecs2, 3));

			var sMtl = _Materials.shader({
				uniforms: {
					u_txue: {
						value: _Tdata.txues._df_p3
					},
					u_time: {
						value: 0
					},
					u_color: {
						value: cArr[0]
					},
					u_opacity: {
						value: cArr[1]
					},
				},
				transparent: true,
				side: THREE.DoubleSide,
				depthWrite: false,
				vertexShader: _Shaders.SpreadVShader,
				fragmentShader: _Shaders.SpreadFShader,
			});
			var _spread = new THREE.Mesh(sGeo, sMtl);

			_spread.position.y = _Tdata.ry;
			_spread._isSpread = true;
			_spread._color = cArr[0];
			_spread._opacity = cArr[1];

			_spread._spread = true;
			_spread._transTimes = 0;
			_spread._perTimes = 3;

			return _spread;
		},

		creatSpot: function (cArr, vec, txue, s) {

			var pGeo = _Geometries.buf(),
				vArr = [vec.x, vec.y, vec.z];
			pGeo.addAttribute('cOffset', new THREE.Float32BufferAttribute([0], 1));
			pGeo.addAttribute('position', new THREE.Float32BufferAttribute(vArr, 3));

			var _spot = new THREE.Points(pGeo, _Materials.shader({
				uniforms: {
					u_txue: {
						value: txue
					},
					u_time: {
						value: 0
					},
					u_color: {
						value: cArr[0]
					},
					u_opacity: {
						value: cArr[1]
					},
					u_size: {
						value: s
					},
				},
				transparent: true,
				vertexShader: _Shaders.SpotVShader,
				fragmentShader: _Shaders.SpotFShader,
			}));

			_spot.position.y = s * 0.55;

			_spot._type = 1;
			_spot._size = s;

			_spot._isSpot = true;
			_spot._color = cArr[0];
			_spot._opacity = cArr[1];

			_spot._undulation = true;
			_spot._py = _spot.position.y;
			_spot._offset = 0.8;
			_spot._transTimes = 0;
			_spot._perTimes = 2;
			_spot._ease = _Collects.ease3;
			_spot._ratio = Math.random();

			return _spot;
		},

		creatTagsArrTxue: function (textArr) {
			var ta = textArr || [],
				cvs1, ctx1;
			cvs1 = document.createElement("canvas");
			ctx1 = cvs1.getContext("2d");

			var s1 = 120,
				s2 = 10,
				s3 = s1 / 2;
			ctx1.font = "bold 100px Arial";

			//-
			var row = ta.length,
				_tw = 0;
			for (var i = 0; i < row; i++) {
				var t = ta[i] || '';
				_tw = Math.max(_tw, ctx1.measureText(t).width);
			}
			var mw = Math.max(row * s1, _tw + s2);
			var _w = Math.max(128, THREE.Math.nextPowerOfTwo(mw));
			cvs1.width = cvs1.height = _w;

			//-
			ctx1.font = "bold 100px Arial";
			ctx1.textAlign = "left";
			ctx1.textBaseline = "middle";

			ctx1.shadowBlur = 54;
			ctx1.shadowColor = "#1A7AE3";

			//-
			ctx1.fillStyle = "#FFF";
			var sy = _w / 2 - row * s3 + s3;
			for (var j = 0; j < row; j++) {
				var tj = ta[j] || '';
				ctx1.fillText(tj, (_w - _tw) / 2, sy + j * s1);
			}

			var texture1 = new THREE.Texture(cvs1);
			texture1.needsUpdate = true;
			texture1._scale = _w / 16;

			return texture1;
		},

		creatTagsTxue: function (text) {
			var t = text || "",
				cvs1, ctx1;
			cvs1 = document.createElement("canvas");
			ctx1 = cvs1.getContext("2d");

			ctx1.font = "bold 100px Arial";
			var _tw = ctx1.measureText(t).width + 2,
				_w = Math.max(128, THREE.Math.nextPowerOfTwo(_tw));
			cvs1.width = cvs1.height = _w;

			//-
			ctx1.font = "bold 100px Arial";
			ctx1.textAlign = "center";
			ctx1.textBaseline = "middle";

			ctx1.shadowBlur = 54;
			ctx1.shadowOffsetY = 0;
			ctx1.shadowColor = "#1F1F1F";

			ctx1.fillStyle = "#FFF";
			ctx1.fillText(t, _w / 2, _w / 2);

			var texture1 = new THREE.Texture(cvs1);
			texture1.needsUpdate = true;
			texture1._scale = _w / 16;

			return texture1;
		},

		//- analysis svg path
		transformSVGPath: function (pathStr) {
			var paths = [];
			var path = new THREE.Shape();

			var DEGS_TO_RADS = Math.PI / 180,
				PERIOD = 46,
				MINUS = 45, // . -
				DIGIT_0 = 48,
				DIGIT_9 = 57,
				COMMA = 44,
				SPACE = 32; // 0 9 , 空格

			var idx = 1,
				len = pathStr.length,
				activeCmd,
				x = 0,
				y = 0,
				nx = 0,
				ny = 0,
				cx, cy, firstX = null,
				firstY = null,
				x1 = null,
				y1 = null,
				x2 = null,
				y2 = null,
				rx = 0,
				ry = 0,
				xar = 0,
				laf = 0,
				sf = 0;

			function eatNum() {
				var sidx, c, isFloat = false,
					s, k = 0;
				while (idx < len) {
					c = pathStr.charCodeAt(idx);
					if (c !== COMMA && c !== SPACE) {
						break;
					}
					idx++;
				}
				if (c === MINUS) {
					sidx = idx++;
				} else {
					sidx = idx;
				}

				while (idx < len) {
					c = pathStr.charCodeAt(idx);
					if (DIGIT_0 <= c && c <= DIGIT_9) {
						idx++;
						continue;
					} else if (c === PERIOD && k < 1) {
						idx++;
						k++;
						isFloat = true;
						continue;
					}
					s = pathStr.substring(sidx, idx);
					return isFloat ? parseFloat(s) : parseInt(s);
				}

				s = pathStr.substring(sidx);
				return isFloat ? parseFloat(s) : parseInt(s);
			}

			function nextIsNum() {
				var c;
				while (idx < len) {
					c = pathStr.charCodeAt(idx);
					if (c !== COMMA && c !== SPACE) {
						break;
					}
					idx++;
				}
				c = pathStr.charCodeAt(idx);
				return (c === MINUS || (DIGIT_0 <= c && c <= DIGIT_9));
			}

			var canRepeat;
			var enteredSub = false;
			var zSeen = false;
			activeCmd = pathStr[0];

			while (idx <= len) {
				canRepeat = true;
				switch (activeCmd) {
					case 'M':
						enteredSub = false;
						x = eatNum();
						y = eatNum();
						path.moveTo(x, y);
						activeCmd = 'L';
						break;
					case 'm':
						x += eatNum();
						y += eatNum();
						path.moveTo(x, y);
						activeCmd = 'l';
						break;
					case 'Z':
					case 'z':
						canRepeat = false;
						if (x !== firstX || y !== firstY) {
							path.lineTo(firstX, firstY);
						}
						paths.push(path);
						firstX = null;
						firstY = null;
						enteredSub = true;
						path = new THREE.Shape();
						zSeen = true;
						break;
					case 'L':
					case 'H':
					case 'V':
						nx = (activeCmd === 'V') ? x : eatNum();
						ny = (activeCmd === 'H') ? y : eatNum();
						path.lineTo(nx, ny);
						x = nx;
						y = ny;
						break;
					case 'l':
					case 'h':
					case 'v':
						nx = (activeCmd === 'v') ? x : (x + eatNum());
						ny = (activeCmd === 'h') ? y : (y + eatNum());
						path.lineTo(nx, ny);
						x = nx;
						y = ny;
						break;
					case 'C':
						x1 = eatNum();
						y1 = eatNum();
					case 'S':
						if (activeCmd === 'S') {
							x1 = (x2 === null) ? x : 2 * x - x2;
							y1 = (y2 === null) ? y : 2 * y - y2;
						}
						x2 = eatNum();
						y2 = eatNum();
						nx = eatNum();
						ny = eatNum();
						path.bezierCurveTo(x1, y1, x2, y2, nx, ny);
						x = nx;
						y = ny;
						break;
					case 'c':
						x1 = x + eatNum();
						y1 = y + eatNum();
					case 's':
						if (activeCmd === 's') {
							x1 = (x2 === null) ? x : 2 * x - x2;
							y1 = (y2 === null) ? y : 2 * y - y2;
						}
						x2 = x + eatNum();
						y2 = y + eatNum();
						nx = x + eatNum();
						ny = y + eatNum();
						path.bezierCurveTo(x1, y1, x2, y2, nx, ny);
						x = nx;
						y = ny;
						break;
					case 'Q':
						x1 = eatNum();
						y1 = eatNum();
					case 'T':
						if (activeCmd === 'T') {
							x1 = (x1 === null) ? x : 2 * x - x1;
							y1 = (y1 === null) ? y : 2 * y - y1;
						}
						nx = eatNum();
						ny = eatNum();
						path.quadraticCurveTo(x1, y1, nx, ny);
						x = nx;
						y = ny;
						break;
					case 'q':
						x1 = x + eatNum();
						y1 = y + eatNum();
					case 't':
						if (activeCmd === 't') {
							x1 = (x1 === null) ? x : 2 * x - x1;
							y1 = (y1 === null) ? y : 2 * y - y1;
						}
						nx = x + eatNum();
						ny = y + eatNum();
						path.quadraticCurveTo(x1, y1, nx, ny);
						x = nx;
						y = ny;
						break;
					case 'A':
					case 'a':
						rx = eatNum();
						ry = eatNum();
						xar = eatNum() * DEGS_TO_RADS;
						laf = eatNum();
						sf = eatNum();
						nx = (activeCmd === 'a') ? x + eatNum() : eatNum();
						ny = (activeCmd === 'a') ? y + eatNum() : eatNum();

						//-
						x1 = Math.cos(xar) * (x - nx) / 2 + Math.sin(xar) * (y - ny) / 2;
						y1 = -Math.sin(xar) * (x - nx) / 2 + Math.cos(xar) * (y - ny) / 2;

						var norm = Math.sqrt((rx * rx * ry * ry - rx * rx * y1 * y1 - ry * ry * x1 * x1) / (rx * rx * y1 * y1 + ry * ry * x1 * x1));
						if (laf === sf) {
							norm = -norm;
						}
						x2 = norm * rx * y1 / ry;
						y2 = norm * -ry * x1 / rx;

						cx = Math.cos(xar) * x2 - Math.sin(xar) * y2 + (x + nx) / 2;
						cy = Math.sin(xar) * x2 + Math.cos(xar) * y2 + (y + ny) / 2;

						//-
						var u = new THREE.Vector2(1, 0),
							v = new THREE.Vector2((x1 - x2) / rx, (y1 - y2) / ry);
						var startAng = Math.acos(u.dot(v) / u.length() / v.length());
						if (u.x * v.y - u.y * v.x < 0) {
							startAng = -startAng;
						}

						u.x = (-x1 - x2) / rx;
						u.y = (-y1 - y2) / ry;

						//-
						var deltaAng = Math.acos(v.dot(u) / v.length() / u.length());
						if (v.x * u.y - v.y * u.x < 0) {
							deltaAng = -deltaAng;
						}
						if (!sf && deltaAng > 0) {
							deltaAng -= Math.PI * 2;
						}
						if (sf && deltaAng < 0) {
							deltaAng += Math.PI * 2;
						}

						//-
						var cw = (sf === 1) ? false : true;
						// path.absarc(cx, cy, rx, startAng, startAng + deltaAng, cw);
						path.absellipse(cx, cy, rx, ry, startAng, startAng + deltaAng, cw);
						x = nx;
						y = ny;
						x1 = null;
						y1 = null;
						x2 = null;
						y2 = null;
						break;
					case ' ':
						break;
					default:
						throw new Error("weird path command: " + activeCmd);
				}
				if (firstX === null && !enteredSub) {
					firstX = x;
					firstY = y;
				}
				if (canRepeat && nextIsNum()) {
					continue;
				}
				activeCmd = pathStr[idx++];
			}

			if (zSeen) {
				return paths;
			} else {
				paths.push(path);
				return paths;
			}
		},

		//- analysis color
		getColorArr: function (str) {
			if (isArray(str)) return str;
			var _arr = [];
			str = str + '';
			str = str.toLowerCase().replace(/\s/g, "");
			if (/^((?:rgba)?)\(\s*([^\)]*)/.test(str)) {
				var arr = str.replace(/rgba\(|\)/gi, '').split(',');
				var hex = [
					pad2(Math.round(arr[0] * 1 || 0).toString(16)),
					pad2(Math.round(arr[1] * 1 || 0).toString(16)),
					pad2(Math.round(arr[2] * 1 || 0).toString(16))
				];
				_arr[0] = _Collects.color('#' + hex.join(""));
				_arr[1] = Math.max(0, Math.min(1, (arr[3] * 1 || 0)));
			} else if ('transparent' === str) {
				_arr[0] = _Collects.color();
				_arr[1] = 0;
			} else {
				_arr[0] = _Collects.color(str);
				_arr[1] = 1;
			}

			function pad2(c) {
				return c.length == 1 ? '0' + c : '' + c;
			}
			return _arr;
		},

		//- loadTexture
		loadTexture: function () {
			var _n = df_Config.texture,
				txueLoader = new THREE.TextureLoader();

			_Tdata.txues._spot = _Collects.creatSpotTexture();
			for (var k in _n) {
				_Tdata.txues['_' + k] = txueLoader.load(_n[k]);
			}
		},

		creatSpotTexture: function (size, power) {
			var s = size * 16 || 256,
				m = power || 2,
				cvs = document.createElement("canvas"),
				ctx = cvs.getContext("2d");
			cvs.width = s;
			cvs.height = s;
			var i, c = 255,
				p = s / 2,
				r = s / 2,
				grad = ctx.createRadialGradient(p, p, 0, p, p, r),
				Cubic = function (k, n) {
					if (n === 2) return k * k;
					if (n === 3) return k * k * k;
					return k;
				};
			for (i = 0; i < s; i++) {
				var p1 = (i / (s - 1)).toFixed(2) * 1,
					o = (1 - p1) * 0.8,
					o1 = Cubic(o, m).toFixed(2),
					c1 = 'rgba(' + c + ',' + c + ',' + c + ',' + o1 + ')';
				grad.addColorStop(p1, c1);
			}
			ctx.fillStyle = grad;
			ctx.arc(p, p, r, 0, 2 * Math.PI);
			ctx.fill();
			var texture = new THREE.Texture(cvs);
			texture.needsUpdate = true;
			return texture;
		},
	};

	var _Materials = {
		point: function (param) {
			return new THREE.PointsMaterial(param);
		},
		line: function (param) {
			return new THREE.LineBasicMaterial(param);
		},
		lineD: function (param) {
			return new THREE.LineDashedMaterial(param);
		},

		sprite: function (param) {
			return new THREE.SpriteMaterial(param);
		},
		shader: function (param) {
			return new THREE.ShaderMaterial(param);
		},
		phong: function (param) {
			return new THREE.MeshPhongMaterial(param);
		},
		basic: function (param) {
			return new THREE.MeshBasicMaterial(param);
		},
		lambert: function (param) {
			return new THREE.MeshLambertMaterial(param);
		},
		standard: function (param) {
			return new THREE.MeshStandardMaterial(param);
		},
	};

	var _Geometries = {
		geo: function () {
			return new THREE.Geometry();
		},
		buf: function () {
			return new THREE.BufferGeometry();
		},

		shape: function (shp, seg) {
			return new THREE.ShapeGeometry(shp, seg);
		},
		extrude: function (shp, opt) {
			return new THREE.ExtrudeGeometry(shp, opt);
		},

		box: function (w, h, d) {
			return new THREE.BoxGeometry(w, h, d);
		},
		sphere: function (r, ws, hs) {
			return new THREE.SphereGeometry(r, ws, hs);
		},
		torus: function (r, t, rs, ts) {
			return new THREE.TorusGeometry(r, t, rs, ts);
		},
		circle: function (r, s) {
			return new THREE.CircleGeometry(r, s);
		},
		Icosah: function (r, s) {
			return new THREE.IcosahedronGeometry(r, s);
		},
		plane: function (w, h, ws, hs) {
			return new THREE.PlaneGeometry(w, h, ws, hs);
		},
		cylinder: function (rt, rb, h, rs, o) {
			return new THREE.CylinderGeometry(rt, rb, h, rs, 1, o);
		},
	};

	var _Tdata = {
		M_PI: 6.2831853071795865,
		M_PI2: 1.57079632679489662,
		sl: 7.2,
		wh: 400,
		st: 200,
		py: 3,
		ry: 0.1,
		txues: {},
		easings: [_Collects.ease1, _Collects.ease2]
	};

	//-
	function init3DMesh(data) {
		thm.SVGMapData = $.extend(true, {}, thm.SVGMapData, data);

		if (thm.mapObject) {
			thm.mapObject.traverse(function (child) {
				if (child.geometry) child.geometry.dispose();
				if (child.material) child.material.dispose();
			});
			thm.scene.remove(thm.mapObject);

			thm.shapesArr = [];
			thm.mEventArr = [];
			thm.shapesArrLen = 0;

			thm.SVGMapObj = {};
		}

		thm.mapObject = _Collects.obj();
		thm.scene.add(thm.mapObject);

		_Collects.handleTags();
		_Collects.handleBlock();
		_Collects.handleBorder();
		_Collects.handleGlow();

		//-
		var series = thm.SVGMapData.series || [];
		handleSeries(series, {
			//
			_fc: df_Config.tags.fontColor,
			_fh: df_Config.tags.fontHover,
			_fs: df_Config.tags.fontSize,
			//
			_bc: df_Config.sceneStyle.blockColor,
			//
			_bh: df_Config.sceneStyle.blockHeight,
			//
			_lc: df_Config.sceneStyle.borderColor,
			_lw: df_Config.sceneStyle.borderWidth,
			//
			_gc: df_Config.outerGlow.glowColor,
			_gs: df_Config.outerGlow.size,
			_gp: df_Config.outerGlow.perTime,
		});

		thm.mapObject.scale.copy(thm.WHRatio);
		thm.mapObject.position.copy(thm.svgOffset);

		for (var j = thm.shapesArrLen - 1, k = 0; j >= 0; j--, k++) {
			var shi = thm.shapesArr[j],
				_r1 = Math.random(),
				_r2 = Math.random(),
				_vec = new THREE.Vector3(_r1 * 8 + 16, 1, _r2 * 8 + 16);
			shi._center.multiply(thm.WHRatio).add(thm.svgOffset);
			shi._admisDic = shi._center.clone().multiply(_vec);
			shi._position = shi.position.clone();

			//-
			var shicc = shi.children[0].children[1];
			if (shicc._hasChild) {
				//-
				var shiCLP = shicc.children[1];
				shiCLP.geometry.attributes.cOffset.array[0] = shi._center.x * 0.0001;
				shiCLP.geometry.attributes.cOffset.needsUpdate = true;
				shiCLP._attrOffset = shiCLP.geometry.attributes.cOffset.array[0];

				//-
				var _c2 = shicc.__vec3,
					key = (shi._migline != 1) ? true : false,
					_s = thm.SVGMapObj[shi._name].point[0],
					cArr = _Collects.getColorArr(_s.linecolor || _s.color);

				if (key) {
					// shicc.add(_Collects.creatMigLine(cArr, _vecStart, _c2));
				}
			}
		}
	}

	function handleSeries(series, opts) {
		series = series || [];
		var _testGeo = _Geometries.geo();

		var _nky1, _nky2, _vec, r1 = 1,
			r2 = 0.4,
			r3 = 0.2,
			bh = opts._bh * 2.5;
		var bc = opts._bc,
			sc = opts._sc,
			lc = opts._lc,
			lw = opts._lw;

		var _tOpt = {
			fc: opts._fc,
			fh: opts._fh,
			fs: opts._fs
		},
			_gopt = {
				gc: opts._gc,
				gs: opts._gs,
				gp: opts._gp
			};

		for (var i = series.length - 1; i >= 0; i--) {
			var _id = series[i]._id;
			if (_id) {
				var _t = series[i].name || 'noName' + _id,
					_p = series[i].point || [],
					_m = series[i].migline || 2,
					_c = _Collects.getColorArr(series[i].color),
					_h = _Collects.clamp(series[i].height * bh, -bh, bh, 0),
					_sp = (series[i].showSpot === true),
					_Shapes = _Collects.transformSVGPath(series[i].path)[0];

				var contour = _Shapes.getPoints(6);
				var _sGeo = _Collects.creatShapeGeo(contour);
				_sGeo.applyMatrix(_Collects.Matrix());
				_testGeo.merge(_sGeo);

				var _lGeo = _Collects.creatSplineGeo(contour, {
					type: 1
				});
				_lGeo.applyMatrix(_Collects.Matrix());

				_nky1 = -bh - 3 - _h;
				_nky2 = -bh * 1.3 - 8 - _h;
				var _extr = _Collects.creatShape(_sGeo, bc, r1, 0),
					_extr1 = _Collects.creatShape(_sGeo, bc, r2, _nky1),
					_extr2 = _Collects.creatShape(_sGeo, bc, r3, _nky2),
					_nExtr = _Collects.creatShape(_sGeo, bc, r1, _h),
					_line = _Collects.creatSVGLine(_lGeo, lc, r1, lw),
					_line1 = _Collects.creatSVGLine(_lGeo, lc, r2, lw),
					_line2 = _Collects.creatSVGLine(_lGeo, lc, r3, lw),
					_glow = _Collects.creatOuterGlow(_Shapes, _gopt, _sp);

				_nExtr._name = _extr._name = _t;
				_nExtr._migline = _extr._migline = _m;
				_nExtr._path_id = _extr._path_id = _id;
				_nExtr._height = _extr._height = series[i].height;

				_nExtr.material.opacity = 0;
				_nExtr.material.depthWrite = false;

				_sGeo.computeBoundingSphere();
				_vec = _sGeo.boundingSphere.center;
				_nExtr._center = _extr._center = _vec.clone();

				var _tags = _Collects.creatTags(_t, _tOpt, _vec, _p);

				_extr1.add(_line1, _glow);
				_extr2.add(_line2);

				_extr.add(_line, _tags, _extr1, _extr2);

				_nExtr.add(_extr);

				thm.mapObject.add(_nExtr);
				thm.shapesArr.push(_nExtr);
				thm.mEventArr.push(_nExtr);

				thm.SVGMapObj[_t] = series[i];

				if (_m === 1) {
					_vecStart = _tags.__vec3;
				}
			}
		}

		thm.shapesArrLen = thm.shapesArr.length;
		getRtoAndOft(_testGeo);
	}

	function getRtoAndOft(tGeo) {
		tGeo.computeBoundingBox();
		var _size = tGeo.boundingBox.getSize(),
			_offset = tGeo.boundingBox.getCenter(),
			_rat = _Tdata.wh / Math.max(_size.x, _size.z);

		thm.WHRatio.set(_rat, 1, _rat);
		// 地图中心偏移
		thm.svgOffset.set(-_offset.x * _rat, 0, -_offset.z * _rat);
	}

	//- animation
	function animation(dt) {
		if (dt < .1 && df_MouseEvent) {
			thm.mapObject.traverse(function (child) {
				if (child._isGlow && child.visible) {
					if (child._flicker) {
						var _times = child._perTimes;
						child._transTimes += dt;
						var _k = child._ratio - child._transTimes / _times;
						if (_k >= 0) _k += 1;
						child.material.opacity = child._opacity * (1 + Math.cos(_k * _Tdata.M_PI) * .5);
						if (child._transTimes >= _times) child._transTimes -= _times;
					}
				}
				if (child._isSpread && child.visible) {
					if (child._spread) {
						var _times = child._perTimes;
						child._transTimes += dt;
						child.material.uniforms.u_time.value = child._transTimes / _times;
						if (child._transTimes >= _times) child._transTimes -= _times;
					}
				}
				if (child._isSpot && child.visible) {
					if (child._undulation) {
						var _times = child._perTimes;
						child._transTimes += dt;
						var _k = child._ratio - child._transTimes / _times;
						if (_k >= 0) _k += 1;
						_k = _Collects.easing(Math.cos(_k * _Tdata.M_PI), child._ease);
						child.position.y = child._py + child._offset * _k;
						var lGeo = child.parent.children[2].geometry;
						lGeo.vertices[1].y = child.position.y;
						lGeo.verticesNeedUpdate = true;
						if (child._transTimes >= _times) child._transTimes -= _times;
					}
				}
				if (child._isMPoint && child.visible) {
					if (child._flowPoint) {
						var _times = child._perTimes;
						child._transTimes += dt;
						child.material.uniforms.u_time.value = child._transTimes / _times;
						if (child._transTimes >= _times) child._transTimes -= _times;
					}
				}
			});
		}

		df_AdmisDic.type && thm.shapesArrLen && setAdmisDic(dt);
		!df_AdmisDic.type && thm.shapesArrLen && AdmisDicRestore();

	}

	// AdmissionDynamic
	function setAdmisDic(dt) {
		var _per = df_AdmisDic.perTime;
		if (df_AdmisDic._transTimes >= _per) return;

		AdmisDicBefore();

		if (dt < .1) {
			df_AdmisDic._transTimes += dt;
			var _k = Math.min(1, df_AdmisDic._transTimes / _per),
				_rk = 1 - _k,
				_vec = new THREE.Vector3(_rk * _rk * _rk, 1, _rk * _rk * _rk);

			for (var j = thm.shapesArrLen - 1; j >= 0; j--) {
				var shpi = thm.shapesArr[j];
				if (df_AdmisDic.type === 1) {
					var shicc = shpi.children[0].children[1];
					shpi.position.copy(shpi._position.clone().add(shpi._admisDic.clone().multiply(_vec)));
					if (_k >= 1) shicc.visible = shicc._visible;
				}
			}

			if (_k >= 1) {
				df_MouseEvent = true;
			}
		}
	}

	function AdmisDicBefore() {
		if (df_AdmisDic._transTimes < 0) {
			df_MouseEvent = false;
			df_AdmisDic._transTimes = 0;
			for (var j = thm.shapesArrLen - 1; j >= 0; j--) {
				if (df_AdmisDic.type === 1) {
					var shi = thm.shapesArr[j],
						shicc = shi.children[0].children[1];
					shi.position.copy(thm.shapesArr[j]._admisDic.clone());
					shicc.visible = false;
				}
			}
		}
	}

	function AdmisDicRestore() {
		if (undefined == df_AdmisDic._transTimes || df_AdmisDic._transTimes < 0) return;

		thm.mapObject.scale.copy(thm.WHRatio);
		thm.mapObject.position.copy(thm.svgOffset);
		df_MouseEvent = true;
		df_AdmisDic._transTimes = -1;
		for (var j = thm.shapesArrLen - 1; j >= 0; j--) {
			var shi = thm.shapesArr[j],
				shicc = shi.children[0].children[1];
			shi.position.copy(thm.shapesArr[j]._position);
			shicc.visible = shicc._visible;
		}
	}

	// mouse event
	function onDocumentMouseUp(event) { }

	function onDocumentMouseWheel(event) { }

	function onDocumentMouseOut(event) {
		thm.container[0].style.cursor = 'auto';
		if (df_ItdMesh) {
			if (df_ItdMesh._isLabel) {
				_Collects.opacityTvs(df_ItdMesh.parent, 1);
				_Collects.colorHight(df_ItdMesh.parent,0);
				df_ItdMesh.parent.material.blending = THREE.NormalBlending;
				df_ItdMesh.parent.children[0].material.blending = THREE.NormalBlending;
			}
			if (df_ItdMesh._isShape) {
				_Collects.opacityTvs(df_ItdMesh, 1);
				_Collects.colorHight(df_ItdMesh,0);
				df_ItdMesh.material.blending = THREE.NormalBlending;
				df_ItdMesh.children[0].material.blending = THREE.NormalBlending;
			}
		}
		df_ItdMesh = null;
	}

	function onDocumentMouseMove(event) {
		event.preventDefault();
		if (df_MouseEvent) {
			df_Mouse.x = (event.layerX / df_Width) * 2 - 1;
			df_Mouse.y = -(event.layerY / df_Height) * 2 + 1;
			df_Raycaster.setFromCamera(df_Mouse, thm.camera);
			df_Intersects = df_Raycaster.intersectObjects(thm.mEventArr);

			if (df_Intersects.length > 0) {
				thm.container[0].style.cursor = 'pointer';

				if (df_ItdMesh) {
					if (df_ItdMesh._isLabel) {
						_Collects.opacityTvs(df_ItdMesh.parent, 1);
						_Collects.colorHight(df_ItdMesh.parent,0);
						df_ItdMesh.parent.material.blending = THREE.NormalBlending;
						df_ItdMesh.parent.children[0].material.blending = THREE.NormalBlending;
					}
					if (df_ItdMesh._isShape) {
						_Collects.opacityTvs(df_ItdMesh, 1);
						_Collects.colorHight(df_ItdMesh.parent,0);
						df_ItdMesh.material.blending = THREE.NormalBlending;
						df_ItdMesh.children[0].material.blending = THREE.NormalBlending;
					}
				}

				var obj = df_Intersects[0].object;
				if (obj._isLabel) {
					df_ItdMesh = obj;
					_Collects.opacityTvs(df_ItdMesh.parent, 1.2);
					_Collects.colorHight(df_ItdMesh.parent,1);
					df_ItdMesh.parent.material.blending = THREE.AdditiveBlending;
					df_ItdMesh.parent.children[0].material.blending = THREE.AdditiveBlending;
				}
				if (obj._isShape) {
					df_ItdMesh = obj.children[0];
					_Collects.opacityTvs(df_ItdMesh, 1.2);
					_Collects.colorHight(df_ItdMesh,1);
					df_ItdMesh.material.blending = THREE.AdditiveBlending;
					df_ItdMesh.children[0].material.blending = THREE.AdditiveBlending;
				}

			} else {
				thm.container[0].style.cursor = 'auto';

				if (df_ItdMesh) {
					if (df_ItdMesh._isLabel) {
						_Collects.opacityTvs(df_ItdMesh.parent, 1);
						_Collects.colorHight(df_ItdMesh.parent,0);
						df_ItdMesh.parent.material.blending = THREE.NormalBlending;
						df_ItdMesh.parent.children[0].material.blending = THREE.NormalBlending;
					}
					if (df_ItdMesh._isShape) {
						_Collects.opacityTvs(df_ItdMesh, 1);
						_Collects.colorHight(df_ItdMesh.parent,0);
						df_ItdMesh.material.blending = THREE.NormalBlending;
						df_ItdMesh.children[0].material.blending = THREE.NormalBlending;
					}
				}
				df_ItdMesh = null;
			}
		}
	}

	function onDocumentMouseDown(event) {
		event.preventDefault();
		df_Mouse.x = (event.layerX / df_Width) * 2 - 1;
		df_Mouse.y = -(event.layerY / df_Height) * 2 + 1;
		df_Raycaster.setFromCamera(df_Mouse, thm.camera);
		df_Intersects = df_Raycaster.intersectObjects(thm.mEventArr);

		if (df_Intersects.length > 0) {
			var obj = df_Intersects[0].object;
			if (df_ItdMesh._isLabel) {
				var _p = obj.parent.parent.parent;
				df_MouseDownCallback(obj._text, transCoord(_p._center), thm.SVGMapObj[_p._name], 2);
			}
			if (obj._isShape) {
				df_MouseDownCallback(obj._name, transCoord(obj._center), thm.SVGMapObj[obj._name], 1);
			}
		}
	}

	function onContResize(event) {
		var wh = getWH();
		df_Width = wh.w;
		df_Height = wh.h;
		thm.camera.aspect = wh.w / wh.h;
		thm.renderer.setSize(wh.w, wh.h);
		thm.camera.updateProjectionMatrix();
	}

	//- renderer
	function renderers(func) {
		var fnc = toFunction(func);
		var Animations = function () {
			if (is_Init) {
				var delta = df_Clock.getDelta();
				if (delta > 0) animation(delta);

				thm.controls.update();
				fnc.bind(thm)(delta);
				thm.renderer.render(thm.scene, thm.camera);
				requestAnimationFrame(Animations);
			}
		};
		Animations();
	}

	function testing() {
		return thm.renderer instanceof THREE.WebGLRenderer;
	}

	function getWH() {
		return {
			w: thm.container.width(),
			h: thm.container.height()
		};
	}

	function setControls(controls, opts, isInit) {

		controls.enablePan = opts.enablePan;
		controls.enableKeys = opts.enablePan;
		controls.enableZoom = opts.enableZoom;
		controls.enableRotate = opts.enableRotate;

		if (isInit) {
			var _opts = default_Config.controls;

			controls.enableDamping = _opts.enableDamping;
			controls.dampingFactor = _opts.dampingFactor;

			controls.panSpeed = _opts.panSpeed;
			controls.zoomSpeed = _opts.zoomSpeed;
			controls.rotateSpeed = _opts.rotateSpeed;

			controls.minDistance = _opts.distance[0];
			controls.maxDistance = _opts.distance[1];
			controls.minPolarAngle = _opts.polarAngle[0];
			controls.maxPolarAngle = _opts.polarAngle[1];
			controls.minAzimuthAngle = _opts.azimuthAngle[0];
			controls.maxAzimuthAngle = _opts.azimuthAngle[1];
		}
	}

	function setControlsOff(controls) {
		controls.enablePan = false;
		controls.enableKeys = false;
		controls.enableZoom = false;
		controls.enableRotate = false;
	}

	function setLight(scene, opts) {
		scene.add(new THREE.AmbientLight(opts.Ambient.color, opts.Ambient.strength));
		if (opts.isHemisphere) {
			var lh = opts.hemisphere,
				hLight = new THREE.HemisphereLight(lh.color, lh.groundColor, lh.strength);
			hLight.position.set(lh.position[0], lh.position[2], lh.position[1]);
			scene.add(hLight);
		}
		if (opts.isDirectional) {
			var ld = opts.directional,
				dlight = new THREE.DirectionalLight(ld.color, ld.strength);
			dlight.position.set(ld.position[0], ld.position[2], ld.position[1]).normalize();
			scene.add(dlight);
		}
	}

	function detector() {
		try {
			return !!window.WebGLRenderingContext && !!document.createElement('canvas').getContext('experimental-webgl');
		} catch (e) {
			return false;
		}
	}

	function isArray(o) {
		return Object.prototype.toString.call(o) == '[object Array]';
	}

	function isFunction(a) {
		return Object.prototype.toString.call(a) === '[object Function]';
	}

	function toFunction(a) {
		var b = Object.prototype.toString.call(a) === '[object Function]';
		return b ? a : function (o) { };
	}

	function parseCts(cts) {
		var $dom = (typeof cts == 'object') ? $(cts) : $('#' + cts);
		if ($dom.length <= 0) return null;
		return $dom;
	}

	function removeEvent() {
		thm.container[0].removeEventListener('mouseup', onDocumentMouseUp, false);
		thm.container[0].removeEventListener('wheel', onDocumentMouseWheel, false);
		thm.container[0].removeEventListener('mouseout', onDocumentMouseOut, false);
		thm.container[0].removeEventListener('mousemove', onDocumentMouseMove, false);
		thm.container[0].removeEventListener('mousedown', onDocumentMouseDown, false);
	}

	function transCoord(position) {
		var halfW = df_Width / 2,
			halfH = df_Height / 2,
			vec3 = position.clone().applyMatrix4(thm.scene.matrix).project(thm.camera),
			mx = Math.round(vec3.x * halfW + halfW),
			my = Math.round(-vec3.y * halfH + halfH);
		return new THREE.Vector2(mx, my);
	}

	// Container
	function creatContainer(id) {
		var containers = $('<div></div>');
		containers.css("cssText", "height:100%;width:100%;overflow:hidden;position:relative !important");
		containers.attr('id', id);
		return containers;
	}

	function creatError(conts, errorText) {
		var error = $('<div class="data-error"></div>'),
			error_text = errorText || '数据错误。。。';
		if (undefined != conts) {
			var ctxt = "color:#fff;position:absolute;top:49%;width:100%;text-align:center;";
			error.css("cssText", ctxt);
			conts.html(error.html(error_text));
		}
	}

};

function __setControls() {
	THREE.OrbitControls = function (F, G) {
		function h() {
			return Math.pow(0.95, a.zoomSpeed);
		}

		function z(b) {
			a.object instanceof THREE.PerspectiveCamera ? k /= b : a.object instanceof THREE.OrthographicCamera ? (a.object.zoom = Math.max(a.minZoom, Math.min(a.maxZoom, a.object.zoom * b)), a.object.updateProjectionMatrix(), y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), a.enableZoom = !1)
		}

		function A(b) {
			a.object instanceof THREE.PerspectiveCamera ? k *= b : a.object instanceof THREE.OrthographicCamera ?
				(a.object.zoom = Math.max(a.minZoom, Math.min(a.maxZoom, a.object.zoom / b)), a.object.updateProjectionMatrix(), y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), a.enableZoom = !1)
		}

		function H(b) {
			if (!1 !== a.enabled) {
				b.preventDefault();
				if (b.button === a.mouseButtons.ORBIT) {
					if (!1 === a.enableRotate) return;
					l.set(b.clientX, b.clientY);
					d = c.ROTATE
				} else if (b.button === a.mouseButtons.ZOOM) {
					if (!1 === a.enableZoom) return;
					m.set(b.clientX, b.clientY);
					d = c.DOLLY
				} else if (b.button ===
					a.mouseButtons.PAN) {
					if (!1 === a.enablePan) return;
					n.set(b.clientX, b.clientY);
					d = c.PAN
				}
				d !== c.NONE && (document.addEventListener("mousemove", B, !1), document.addEventListener("mouseup", C, !1), a.dispatchEvent(D))
			}
		}

		function B(b) {
			!1 !== a.enabled && (b.preventDefault(), d === c.ROTATE ? !1 !== a.enableRotate && (p.set(b.clientX, b.clientY), q.subVectors(p, l), b = a.domElement === document ? a.domElement.body : a.domElement, e.theta -= 2 * Math.PI * q.x / b.clientWidth * a.rotateSpeed, e.phi -= 2 * Math.PI * q.y / b.clientHeight * a.rotateSpeed, l.copy(p), a.update()) :
				d === c.DOLLY ? !1 !== a.enableZoom && (r.set(b.clientX, b.clientY), t.subVectors(r, m), 0 < t.y ? z(h()) : 0 > t.y && A(h()), m.copy(r), a.update()) : d === c.PAN && !1 !== a.enablePan && (u.set(b.clientX, b.clientY), v.subVectors(u, n).multiplyScalar(a.panSpeed), w(v.x, v.y), n.copy(u), a.update()))
		}

		function C(b) {
			!1 !== a.enabled && (document.removeEventListener("mousemove", B, !1), document.removeEventListener("mouseup", C, !1), a.dispatchEvent(E), d = c.NONE)
		}

		function I(b) {
			!1 === a.enabled || !1 === a.enableZoom || d !== c.NONE && d !== c.ROTATE || (b.preventDefault(),
				b.stopPropagation(), 0 > b.deltaY ? A(h()) : 0 < b.deltaY && z(h()), a.update(), a.dispatchEvent(D), a.dispatchEvent(E))
		}

		function J(b) {
			if (!1 !== a.enabled && !1 !== a.enableKeys && !1 !== a.enablePan) switch (b.keyCode) {
				case a.keys.UP:
					w(0, 7 * -a.panSpeed);
					a.update();
					break;
				case a.keys.BOTTOM:
					w(0, 7 * a.panSpeed);
					a.update();
					break;
				case a.keys.LEFT:
					w(7 * -a.panSpeed, 0);
					a.update();
					break;
				case a.keys.RIGHT:
					w(7 * a.panSpeed, 0), a.update()
			}
		}

		function K(b) {
			if (!1 !== a.enabled) {
				switch (b.touches.length) {
					case 1:
						if (!1 === a.enableRotate) return;
						l.set(b.touches[0].pageX,
							b.touches[0].pageY);
						d = c.TOUCH_ROTATE;
						break;
					case 2:
						if (!1 === a.enableZoom) return;
						var g = b.touches[0].pageX - b.touches[1].pageX;
						b = b.touches[0].pageY - b.touches[1].pageY;
						m.set(0, Math.sqrt(g * g + b * b));
						d = c.TOUCH_DOLLY;
						break;
					case 3:
						if (!1 === a.enablePan) return;
						n.set(b.touches[0].pageX, b.touches[0].pageY);
						d = c.TOUCH_PAN;
						break;
					default:
						d = c.NONE
				}
				d !== c.NONE && a.dispatchEvent(D)
			}
		}

		function L(b) {
			if (!1 !== a.enabled) switch (b.preventDefault(), b.stopPropagation(), b.touches.length) {
				case 1:
					if (!1 === a.enableRotate) break;
					if (d !== c.TOUCH_ROTATE) break;
					p.set(b.touches[0].pageX, b.touches[0].pageY);
					q.subVectors(p, l);
					var g = a.domElement === document ? a.domElement.body : a.domElement;
					e.theta -= 2 * Math.PI * q.x / g.clientWidth * a.rotateSpeed;
					e.phi -= 2 * Math.PI * q.y / g.clientHeight * a.rotateSpeed;
					l.copy(p);
					a.update();
					break;
				case 2:
					if (!1 === a.enableZoom) break;
					if (d !== c.TOUCH_DOLLY) break;
					g = b.touches[0].pageX - b.touches[1].pageX;
					b = b.touches[0].pageY - b.touches[1].pageY;
					r.set(0, Math.sqrt(g * g + b * b));
					t.subVectors(r, m);
					0 < t.y ? A(h()) : 0 > t.y && z(h());
					m.copy(r);
					a.update();
					break;
				case 3:
					if (!1 ===
						a.enablePan) break;
					if (d !== c.TOUCH_PAN) break;
					u.set(b.touches[0].pageX, b.touches[0].pageY);
					v.subVectors(u, n);
					w(v.x, v.y);
					n.copy(u);
					a.update();
					break;
				default:
					d = c.NONE
			}
		}

		function M(b) {
			!1 !== a.enabled && (a.dispatchEvent(E), d = c.NONE)
		}

		function N(a) {
			a.preventDefault()
		}
		this.object = F;
		this.domElement = void 0 !== G ? G : document;
		this.enabled = !0;
		this.target = new THREE.Vector3;
		this.minDistance = 0;
		this.maxDistance = Infinity;
		this.minZoom = 0;
		this.maxZoom = Infinity;
		this.minPolarAngle = 0;
		this.maxPolarAngle = Math.PI;
		this.minAzimuthAngle = -Infinity;
		this.maxAzimuthAngle = Infinity;
		this.enableDamping = !1;
		this.dampingFactor = .25;
		this.enableZoom = !0;
		this.zoomSpeed = 1;
		this.enableRotate = !0;
		this.rotateSpeed = 1;
		this.enablePan = !0;
		this.panSpeed = 1;
		this.autoRotate = !1;
		this.autoRotateSpeed = 2;
		this.enableKeys = !0;
		this.keys = {
			LEFT: 37,
			UP: 38,
			RIGHT: 39,
			BOTTOM: 40
		};
		this.mouseButtons = {
			ORBIT: THREE.MOUSE.LEFT,
			ZOOM: THREE.MOUSE.MIDDLE,
			PAN: THREE.MOUSE.RIGHT
		};
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;
		this.getPolarAngle =
			function () {
				return f.phi
			};
		this.getAzimuthalAngle = function () {
			return f.theta
		};
		this.reset = function () {
			a.target.copy(a.target0);
			a.object.position.copy(a.position0);
			a.object.zoom = a.zoom0;
			a.object.updateProjectionMatrix();
			a.dispatchEvent(O);
			a.update();
			d = c.NONE
		};
		this.update = function () {
			var b = new THREE.Vector3,
				g = (new THREE.Quaternion).setFromUnitVectors(F.up, new THREE.Vector3(0, 1, 0)),
				U = g.clone().inverse(),
				P = new THREE.Vector3,
				Q = new THREE.Quaternion;
			return function () {
				var h = a.object.position;
				b.copy(h).sub(a.target);
				b.applyQuaternion(g);
				f.setFromVector3(b);
				a.autoRotate && d === c.NONE && (e.theta -= 2 * Math.PI / 60 / 60 * a.autoRotateSpeed);
				f.theta += e.theta;
				f.phi += e.phi;
				f.theta = Math.max(a.minAzimuthAngle, Math.min(a.maxAzimuthAngle, f.theta));
				f.phi = Math.max(a.minPolarAngle, Math.min(a.maxPolarAngle, f.phi));
				f.makeSafe();
				f.radius *= k;
				f.radius = Math.max(a.minDistance, Math.min(a.maxDistance, f.radius));
				a.target.add(x);
				b.setFromSpherical(f);
				b.applyQuaternion(U);
				h.copy(a.target).add(b);
				a.object.lookAt(a.target);
				!0 === a.enableDamping ? (k +=
					(1 - k) * a.dampingFactor * .6, e.theta *= 1 - a.dampingFactor, e.phi *= 1 - a.dampingFactor, x.multiplyScalar(1 - a.dampingFactor)) : (k = 1, e.set(0, 0, 0), x.set(0, 0, 0));
				return y || P.distanceToSquared(a.object.position) > R || 8 * (1 - Q.dot(a.object.quaternion)) > R ? (a.dispatchEvent(O), P.copy(a.object.position), Q.copy(a.object.quaternion), y = !1, !0) : !1
			}
		}();
		this.dispose = function () {
			a.domElement.removeEventListener("contextmenu", N, !1);
			a.domElement.removeEventListener("mousedown", H, !1);
			a.domElement.removeEventListener("wheel", I, !1);
			a.domElement.removeEventListener("touchstart",
				K, !1);
			a.domElement.removeEventListener("touchend", M, !1);
			a.domElement.removeEventListener("touchmove", L, !1);
			document.removeEventListener("mousemove", B, !1);
			document.removeEventListener("mouseup", C, !1);
			window.removeEventListener("keydown", J, !1)
		};
		var a = this,
			O = {
				type: "change"
			},
			D = {
				type: "start"
			},
			E = {
				type: "end"
			},
			c = {
				NONE: -1,
				ROTATE: 0,
				DOLLY: 1,
				PAN: 2,
				TOUCH_ROTATE: 3,
				TOUCH_DOLLY: 4,
				TOUCH_PAN: 5
			},
			d = c.NONE,
			R = 1E-6,
			f = new THREE.Spherical,
			e = new THREE.Spherical,
			k = 1,
			x = new THREE.Vector3,
			y = !1,
			l = new THREE.Vector2,
			p = new THREE.Vector2,
			q = new THREE.Vector2,
			n = new THREE.Vector2,
			u = new THREE.Vector2,
			v = new THREE.Vector2,
			m = new THREE.Vector2,
			r = new THREE.Vector2,
			t = new THREE.Vector2,
			S = function () {
				var a = new THREE.Vector3;
				return function (b, c) {
					a.setFromMatrixColumn(c, 0);
					a.multiplyScalar(-b);
					x.add(a)
				}
			}(),
			T = function () {
				var a = new THREE.Vector3;
				return function (b, c) {
					a.setFromMatrixColumn(c, 1);
					a.multiplyScalar(b);
					x.add(a)
				}
			}(),
			w = function () {
				var b = new THREE.Vector3;
				return function (c, d) {
					var e = a.domElement === document ? a.domElement.body : a.domElement;
					if (a.object instanceof THREE.PerspectiveCamera) {
						b.copy(a.object.position).sub(a.target);
						var f = b.length(),
							f = f * Math.tan(a.object.fov / 2 * Math.PI / 180);
						S(2 * c * f / e.clientHeight, a.object.matrix);
						T(2 * d * f / e.clientHeight, a.object.matrix)
					} else a.object instanceof THREE.OrthographicCamera ? (S(c * (a.object.right - a.object.left) / a.object.zoom / e.clientWidth, a.object.matrix), T(d * (a.object.top - a.object.bottom) / a.object.zoom / e.clientHeight, a.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
						a.enablePan = !1)
				}
			}();
		a.domElement.addEventListener("contextmenu", N, !1);
		a.domElement.addEventListener("mousedown", H, !1);
		a.domElement.addEventListener("wheel", I, !1);
		a.domElement.addEventListener("touchstart", K, !1);
		a.domElement.addEventListener("touchend", M, !1);
		a.domElement.addEventListener("touchmove", L, !1);
		window.addEventListener("keydown", J, !1);
		this.update()
	};
	THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
	THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
}